decide how a CBOR codec Decode() method should work

Help decide how a CBOR codec package's Decode() method should work.
The codec must use the "github.com/fxamacker/cbor/v2" package as its
decoding engine.  

The choices seem to be:

- return a pointer to an existing instance of the type being decoded
  - this would mean passing in a zero-valued instance of the type
  - this is similar to how the encoding/json package works
  - the caller must be able to provide either nil or a zero-valued
    interface{} value in cases where the caller doesn't know the type
    being decoded
  - the caller must not need to import reflect
- return a pointer to a new instance of the type being decoded
  - the pointer must be a conventional Go pointer, not an interface,
    and not a reflect-related thing 
  - the caller must not need to import reflect
- return a value of the type being decoded
  - the value must be a conventional Go value, not an interface, and
    not a reflect-related thing
  - the caller must not need to import reflect

An alternative choice that may apply to any or all of the above is to
return both the decoded value and the tag number, if any, as separate
return values, and let the caller cast the value to the correct type
or otherwise handle it as needed.

Write a version of each possible variant, along with a test case
showing examples of how each choice would be used. The encoded data
must be actual CBOR data, not simulated; remove all simulated data
from the test cases, and remove all handling of simulated data from
the codec.  The tag must be an actual CBOR tag, not a simulated one,
and not a simple prepended byte; remove the code that simulates a
non-CBOR tag.

Explain the difference between cbor.RawTag and cbor.Tag, and justify
the choice of one or the other in the code.

Attempt to add an example in which the caller doesn't know the type
being decoded, and must pass in nil, a zero-valued interface{} value,
or something else that doesn't require importing reflect.

Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
  x/cbor-decode/decode.go
  x/cbor-decode/decode_test.go
Out:
  x/cbor-decode/decode.go
  x/cbor-decode/decode_test.go

.stop

 x/cbor-codec/codec/codec.go
 x/cbor-codec/codec/codec_test.go

fix test error

=== RUN   TestEncode/GridPayload
1735551332({"ID": '\u0001\u0002', "Timestamp": 1614124800})
    codec_test.go:114: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:114
                Error:          Not equal: 
                                expected: codec_test.GridPayload(codec_test.GridPayload{ID:[]uint8{0x1, 0x2}, Timestamp:0x60359700})
                                actual  : *codec_test.GridPayload(&codec_test.GridPayload{ID:[]uint8{0x1, 0x2}, Timestamp:0x60359700})
                            
                                Diff:
                                --- Expected
                                +++ Actual
                                @@ -1,2 +1,2 @@
                                -(codec_test.GridPayload) {
                                +(*codec_test.GridPayload)({
                                  ID: ([]uint8) (len=2) {
                                @@ -5,3 +5,3 @@
                                  Timestamp: (uint64) 1614124800
                                -}
                                +})
                                 
                Test:           TestEncode/GridPayload


Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 x/interfaces-git/interfaces-git.go
 x/interfaces-git/interfaces-git_test.go
 x/cbor-codec/codec/codec.go
 x/cbor-codec/codec/codec_test.go
.stop

Out:
 x/interfaces-git/interfaces-git_test.go

.stop

 x/cbor-codec/codec/codec.go
 x/cbor-codec/codec/codec_test.go


.stop

 x/interfaces-git/interfaces-git.go
 x/interfaces-git/interfaces-git_test.go

.stop

recommend a better design than the Get* methods but that still
satisfies the requirements for CBOR encoding and decoding; we don't
want method names and field names to be the same

ensure Store is thread-safe


recommend a data structure 

problem:

- for the application described in README.md
- that can store a large number of large byte sequences 
- that can find a small subsequence of bytes among all large byte
  sequences
- small sequence size ranges from a few bytes to hundreds of megabytes
- large sequence size ranges from a few bytes to hundreds of gigabytes 
- number of large sequences ranges from a few to billions
- must be able to handle variable-length byte sequences
- must be able to handle sequences containing any byte value
- must be able to handle sequences containing any arbitrary sequence of
  bytes
- must be able to handle frequent appends to large sequences
- must be able to handle slight modifications to large sequences while
  preserving the original large sequence (e.g. maybe the set of all
  versions of a large sequence is a graph structure)
  
changes:

- expand merkle DAG description and usage
- refine conclusions
- make no other changes

Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 README.md
 x/data-structure/description.md
Out: 
 x/data-structure/description.md

.stop

- backrefs are in messages via hash chain
- forward refs are on disk
