add DecodeTag, fix DecodeValue signature

Add this function to the cbor-decode package:

DecodeTag([]byte) (uint64, []byte, error)

DecodeTag decodes a CBOR tag from a byte slice.  It returns the tag
number, the tag data, and an error.  If the byte slice does not contain
a tag, it returns 0, nil, nil.

Fix the signature of DecodeValue to look like this:

DecodeValue([]byte, interface{}) error

In other words, we will pass a byte slice and a pointer to a value to
decode into, rather than using generics.  

In:
 x/cbor-decode/decode.go
 x/cbor-decode/decode_test.go
Out:
 x/cbor-decode/decode.go
 x/cbor-decode/decode_test.go

.stop

update cbor-codec based on cbor-decode lessons learned

Examine the cbor-decode package and its tests. Update the cbor-codec
package to use the same techniques as cbor-decode.  Do not import the
cbor-decode package into the cbor-codec package. Do not use
reflect.  Keep the code as simple as the cbor-decode package.

Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 x/cbor-codec/codec.go
 x/cbor-codec/codec_test.go
 x/cbor-decode/decode.go
 x/cbor-decode/decode_test.go
Out:
 x/cbor-codec/codec.go
 x/cbor-codec/codec_test.go

.stop

Out:
  x/cbor-decode/decode.go
  x/cbor-decode/decode_test.go

.stop



Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 x/interfaces-git/interfaces-git.go
 x/interfaces-git/interfaces-git_test.go
 x/cbor-codec/codec/codec.go
 x/cbor-codec/codec/codec_test.go
.stop

Out:
 x/interfaces-git/interfaces-git_test.go

.stop

 x/cbor-codec/codec/codec.go
 x/cbor-codec/codec/codec_test.go


.stop

 x/interfaces-git/interfaces-git.go
 x/interfaces-git/interfaces-git_test.go

.stop

recommend a better design than the Get* methods but that still
satisfies the requirements for CBOR encoding and decoding; we don't
want method names and field names to be the same

ensure Store is thread-safe


recommend a data structure 

problem:

- for the application described in README.md
- that can store a large number of large byte sequences 
- that can find a small subsequence of bytes among all large byte
  sequences
- small sequence size ranges from a few bytes to hundreds of megabytes
- large sequence size ranges from a few bytes to hundreds of gigabytes 
- number of large sequences ranges from a few to billions
- must be able to handle variable-length byte sequences
- must be able to handle sequences containing any byte value
- must be able to handle sequences containing any arbitrary sequence of
  bytes
- must be able to handle frequent appends to large sequences
- must be able to handle slight modifications to large sequences while
  preserving the original large sequence (e.g. maybe the set of all
  versions of a large sequence is a graph structure)
  
changes:

- expand merkle DAG description and usage
- refine conclusions
- make no other changes

Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 README.md
 x/data-structure/description.md
Out: 
 x/data-structure/description.md

.stop

- backrefs are in messages via hash chain
- forward refs are on disk
