fix test errors

=== RUN   TestEncode
=== RUN   TestEncode/GridPayload
=== RUN   TestEncode/ImagePayload
--- PASS: TestEncode (0.00s)
    --- PASS: TestEncode/GridPayload (0.00s)
    --- PASS: TestEncode/ImagePayload (0.00s)
=== RUN   TestDecode
=== RUN   TestDecode/GridPayload
    codec_test.go:121: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:121
                Error:          Received unexpected error:
                                expected inner cbor.Tag, got map[interface {}]interface {}
                Test:           TestDecode/GridPayload
    codec_test.go:122: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:122
                Error:          Not equal: 
                                expected: codec_test.GridPayload(codec_test.GridPayload{ID:[]uint8{0x1, 0x2}, Timestamp:0x60359700})
                                actual  : <nil>(<nil>)
                Test:           TestDecode/GridPayload
=== RUN   TestDecode/ImagePayload
    codec_test.go:121: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:121
                Error:          Received unexpected error:
                                cbor: 5 bytes of extraneous data starting at index 20
                Test:           TestDecode/ImagePayload
    codec_test.go:122: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:122
                Error:          Not equal: 
                                expected: codec_test.ImagePayload(codec_test.ImagePayload{Width:0x320, Height:0x258, Format:"JPEG"})
                                actual  : <nil>(<nil>)
                Test:           TestDecode/ImagePayload
--- FAIL: TestDecode (0.00s)
    --- FAIL: TestDecode/GridPayload (0.00s)
    --- FAIL: TestDecode/ImagePayload (0.00s)
=== RUN   TestUnknownTag
    codec_test.go:134: 
                Error Trace:    /home/stevegt/lab/grid-poc/x/cbor-codec/codec/codec_test.go:134
                Error:          "cbor: tag number 1 must be followed by integer or floating-point number, got map" does not contain "unknown tag"
                Test:           TestUnknownTag
--- FAIL: TestUnknownTag (0.00s)
=== RUN   TestInvalidStructure
--- PASS: TestInvalidStructure (0.00s)


Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 x/cbor-codec/codec/codec.go
Out:
 x/cbor-codec/codec/codec.go

.stop

 x/cbor-codec/codec/codec_test.go


.stop

 x/interfaces-git/interfaces-git.go
 x/interfaces-git/interfaces-git_test.go

.stop

recommend a better design than the Get* methods but that still
satisfies the requirements for CBOR encoding and decoding; we don't
want method names and field names to be the same

ensure Store is thread-safe


recommend a data structure 

problem:

- for the application described in README.md
- that can store a large number of large byte sequences 
- that can find a small subsequence of bytes among all large byte
  sequences
- small sequence size ranges from a few bytes to hundreds of megabytes
- large sequence size ranges from a few bytes to hundreds of gigabytes 
- number of large sequences ranges from a few to billions
- must be able to handle variable-length byte sequences
- must be able to handle sequences containing any byte value
- must be able to handle sequences containing any arbitrary sequence of
  bytes
- must be able to handle frequent appends to large sequences
- must be able to handle slight modifications to large sequences while
  preserving the original large sequence (e.g. maybe the set of all
  versions of a large sequence is a graph structure)
  
changes:

- expand merkle DAG description and usage
- refine conclusions
- make no other changes

Sysmsg: You are an expert Go programmer. Please make the requested changes to the given code or documentation.
In: 
 README.md
 x/data-structure/description.md
Out: 
 x/data-structure/description.md

.stop

- backrefs are in messages via hash chain
- forward refs are on disk
