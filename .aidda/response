File: /home/stevegt/lab/grid-poc/x/sim2/sim2.go
```go
package main

import (
	"fmt"
	"strings"
)

// Message represents a bid or ask message in the simulation.
// Every message must be either a bid or an ask and include a personal
// currency symbol and an amount.
type Message struct {
	Type    string   // "BID" or "ASK"
	Amount  float64  // bid or ask amount
	Symbol  string   // personal currency symbol (e.g. "ALICE")
	From    string   // sender agent ID
	History []string // list of agent IDs that have handled the message
}

// Agent represents a simulation participant.
type Agent struct {
	ID       string
	Currency string  // personal currency (e.g. "ALICE")
	Balance  float64
	Peers    []*Agent
	IsSeller bool // Only Dave is the seller.
	IsBuyer  bool // Only Alice is the buyer.
}

// SendMessage sends a message to all peers, skipping those already in the
// message history to avoid loops. If the message's symbol is empty, it uses
// the sender's personal currency.
func (a *Agent) SendMessage(msg Message) {
	if msg.Symbol == "" {
		msg.Symbol = a.Currency
	}
	// Append self to history.
	msg.History = append(msg.History, a.ID)
	for _, peer := range a.Peers {
		// Avoid sending to peers already in the history.
		if contains(msg.History, peer.ID) {
			continue
		}
		fmt.Printf("%s sends %s message (%.2f%s) to %s\n",
			a.ID, msg.Type, msg.Amount, msg.Symbol, peer.ID)
		peer.ReceiveMessage(msg, a)
	}
}

// ReceiveMessage processes an incoming message based on type and role.
// Sellers respond to BID messages by issuing an ASK using their own currency;
// buyers accept acceptable ASK messages. Intermediate agents simply forward
// messages.
func (a *Agent) ReceiveMessage(msg Message, sender *Agent) {
	// Avoid reprocessing if already in history.
	if contains(msg.History, a.ID) {
		return
	}
	msg.History = append(msg.History, a.ID)

	// Seller behavior: on receiving a BID, respond with an ASK.
	if msg.Type == "BID" && a.IsSeller {
		// For this simulation, seller sets ask price lower than bid by 5.
		askPrice := msg.Amount - 5.0
		if askPrice < 0 {
			askPrice = 0
		}
		askMsg := Message{
			Type:    "ASK",
			Amount:  askPrice,
			Symbol:  a.Currency,
			From:    a.ID,
			History: []string{},
		}
		fmt.Printf("%s received BID from %s, responds with ASK (%.2f%s)\n",
			a.ID, msg.From, askMsg.Amount, askMsg.Symbol)
		a.SendMessage(askMsg)
		return
	}

	// Buyer behavior: on receiving an ASK, if the price is acceptable,
	// execute the trade.
	if msg.Type == "ASK" && a.IsBuyer {
		// Buyer accepts the ASK if the price is less than or equal to 50.
		if msg.Amount <= 50.0 {
			fmt.Printf("%s (buyer) received ASK from %s with price %.2f%s, "+
				"trade executed!\n", a.ID, msg.From, msg.Amount, msg.Symbol)
			a.Balance -= msg.Amount
			// Find the seller in the network; assume the seller is Dave.
			seller := findAgentByID(a.Peers, msg.From)
			if seller != nil {
				seller.Balance += msg.Amount
				fmt.Printf("Trade settled: %s pays %.2f%s to %s\n",
					a.ID, msg.Amount, msg.Symbol, seller.ID)
			} else {
				fmt.Printf("Seller %s not found among direct peers.\n", msg.From)
			}
			return
		}
		fmt.Printf("%s (buyer) received high ASK price %.2f%s from %s, "+
			"rejecting trade\n", a.ID, msg.Amount, msg.Symbol, msg.From)
		return
	}

	// Intermediate agent: forward the message along the network.
	fmt.Printf("%s received %s message from %s, forwarding...\n",
		a.ID, msg.Type, sender.ID)
	a.SendMessage(msg)
}

// contains returns true if s is in the slice.
func contains(slice []string, s string) bool {
	for _, v := range slice {
		if v == s {
			return true
		}
	}
	return false
}

// findAgentByID returns the first agent in agents with a matching ID.
func findAgentByID(agents []*Agent, id string) *Agent {
	for _, agent := range agents {
		if agent.ID == id {
			return agent
		}
	}
	return nil
}

// RunSimulation initializes the four agents and simulates a double-auction
// message pass using personal currencies across a multi-hop network.
// Scenario: Alice, Bob, and Carol are peers; Bob, Carol, and Dave are peers.
// Alice and Dave cannot communicate directly.
func RunSimulation() (alice, bob, carol, dave *Agent) {
	// Create agents with an initial balance of 100 and assign personal currency.
	alice = &Agent{ID: "Alice", Balance: 100.0, IsBuyer: true,
		Currency: "ALICE"}
	bob = &Agent{ID: "Bob", Balance: 100.0, Currency: "BOB"}
	carol = &Agent{ID: "Carol", Balance: 100.0, Currency: "CAROL"}
	dave = &Agent{ID: "Dave", Balance: 100.0, IsSeller: true,
		Currency: "DAVE"}

	// Set up peer connections:
	// Alice, Bob, and Carol are mutually connected.
	// Bob, Carol, and Dave are mutually connected.
	alice.Peers = []*Agent{bob, carol}
	bob.Peers = []*Agent{alice, carol, dave}
	carol.Peers = []*Agent{alice, bob, dave}
	dave.Peers = []*Agent{bob, carol}

	// Alice initiates the auction by sending a BID message with her currency.
	bidMsg := Message{
		Type:    "BID",
		Amount:  50.0,
		Symbol:  alice.Currency,
		From:    alice.ID,
		History: []string{},
	}
	alice.SendMessage(bidMsg)
	return alice, bob, carol, dave
}

// simulateAuction runs the simulation and prints final agent balances.
func simulateAuction() {
	alice, bob, carol, dave := RunSimulation()
	fmt.Println("\nFinal Balances:")
	// Display each agent's balance along with their personal currency.
	fmt.Printf("Alice: %.2f %s\n", alice.Balance, alice.Currency)
	fmt.Printf("Bob: %.2f %s\n", bob.Balance, bob.Currency)
	fmt.Printf("Carol: %.2f %s\n", carol.Balance, carol.Currency)
	fmt.Printf("Dave: %.2f %s\n", dave.Balance, dave.Currency)
}

func main() {
	fmt.Println(strings.Repeat("=", 70))
	fmt.Println("Starting Auction Simulation")
	fmt.Println(strings.Repeat("=", 70))
	simulateAuction()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2.go

File: /home/stevegt/lab/grid-poc/x/sim2/sim2_test.go
```go
package main

import "testing"

// TestSimulationTrade verifies that a trade occurs during the simulation.
// We expect the buyer (Alice) to pay the ask price (assumed to be 5 less than
// the bid of 50) and the seller (Dave) to receive that amount.
func TestSimulationTrade(t *testing.T) {
	alice, _, _, dave := RunSimulation()
	// In our simulation, Dave (seller) responds with an ASK price of 45.
	expectedBuyerBalance := 100.0 - 45.0
	expectedSellerBalance := 100.0 + 45.0

	if alice.Balance != expectedBuyerBalance {
		t.Errorf("Expected Alice balance to be %.2f, got %.2f",
			expectedBuyerBalance, alice.Balance)
	}
	if dave.Balance != expectedSellerBalance {
		t.Errorf("Expected Dave balance to be %.2f, got %.2f",
			expectedSellerBalance, dave.Balance)
	}
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2_test.go