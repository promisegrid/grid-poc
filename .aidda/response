File: /home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md
```markdown
# Worldline Completion Model in Messaging Systems

The worldline completion model offers an innovative approach to managing events in a messaging system by leveraging a Merkle DAG structure to create a complete, verifiable history of events. In this model, every message is a Directed Acyclic Graph (DAG) edit operation—a promise (in Promise Theory style as described by Mark Burgess) that ensures the resulting worldline(s) are valid. This document explains what a worldline data structure might look like, how it could be implemented, and reviews examples of DAG edit, query, and subscription messages expressed as CWT claims. It also provides concrete scenarios involving agents such as Alice and Bob.

---

## Overview of the Worldline Completion Model

Key aspects of the model include:

- **Multiple Worldlines with Branching and Merging:**  
  Multiple concurrent worldlines are supported. They can branch and merge, and a single event may appear in several worldlines at once.

- **Message as a DAG Edit Operation:**  
  Each message is an operation that edits the Merkle DAG. This edit operation—whether it is an insertion, deletion, or reordering—is a promise that, when applied with the provided context (including previous internal node hashes), results in a valid worldline state.

- **Merkle DAG Architecture:**  
  - **Leaves as Events:**  
    Events are stored as leaves in the DAG. Each event contains:
      - A payload of one or more PT-style promises expressed as CWT claims.
      - A timestamp, which reflects the agent’s local perspective at the time of event creation.
      - A digital signature by the creating agent.
    Importantly, these leaves do not include the hash of the previous event to avoid redundancy.
  
  - **Internal Nodes as Edit Logs:**  
    Internal nodes are analogous to logs that record messages (edit operations) that have modified the worldline. They store the hashes of their children in order and ensure that each edit operation can be validated by replaying past messages.

- **Unified Editing, Querying, and Subscription Language:**  
  The same language is used for all DAG operations—whether editing, querying, or subscribing. This language is expressible as structured claims (using CWT claims), promoting consistency across low-level operations.

- **Terminology Clarification:**  
  In this system, the terms are used as follows:
  - **"Event"**: An immutable record stored as a leaf in the Merkle DAG.
  - **"Message"**: The edit operation that carries one or more CWT claims (promises) to modify, query, or subscribe to a worldline.
  
  Although the terms “message” and “event” might sometimes be used interchangeably, we recommend that “event” be reserved for the immutable DAG record, while “message” be used for the corresponding DAG edit (or query/subscription) operation.

- **Replayability:**  
  Because each DAG edit includes the hashes of existing nodes, the system supports complete replayability. This feature allows for state re-creation as of any point in time, similar to reconstructing Git repositories.

---

## Worldline Data Structure

A potential Go-style structure representing an event within a worldline could be:

```go
type WorldlineEvent struct {
    Timestamp time.Time // Timestamp from the creating agent's perspective.
    Agent     string    // Identifier of the creator (e.g., "Alice" or "Bob").
    Payload   []byte    // A set of PT-style promises expressed as CWT claims.
    Signature []byte    // Digital signature from the agent.
}
```

### Merkle DAG Essentials

- **Leaf Nodes (Events):**  
  Leaves store the payload, timestamp, and signature. They do not include previous hashes.

- **Internal Nodes (Edit Logs):**  
  These nodes log the messages (edit operations) performed on the worldline. Each internal node contains the hashes of its children—in the order of the worldline—to verify the sequence of edit operations.

---

## Example Scenarios

### 1. DAG Edit Message Examples

DAG edit messages are promises that modify one or more worldlines. These messages include operations such as insertion, deletion, and reordering, and are structured as properly formatted CWT claims.

#### a. Insert Operation

Alice wants to add a new event to an existing worldline. Her message includes previous internal node hashes to serve as the context for the edit.

**Example JSON:**

```json
{
  "op": "insert",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:05:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Insert event 'Hello' as an initial greeting", "detail": "Welcome message"}
    ]
  },
  "prevHashes": ["hash_internalNode1", "hash_internalNode2"],
  "signature": "AliceSignatureABC123"
}
```

#### b. Delete Operation

Bob decides to delete an outdated event from a worldline, using a deletion message that carries the necessary context.

**Example JSON:**

```json
{
  "op": "delete",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:20:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Delete event 'Obsolete'", "detail": "Removing outdated information"}
    ]
  },
  "prevHashes": ["hash_internalNode3"],
  "signature": "BobSignatureXYZ789"
}
```

#### c. Reorder Operation

Alice issues a reorder operation to adjust the event ordering within a worldline. The new order is cryptographically verifiable due to the inclusion of prior internal node hashes.

**Example JSON:**

```json
{
  "op": "reorder",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:30:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Reorder events to prioritize recent updates", "detail": "Moving update event up"}
    ]
  },
  "prevHashes": ["hash_internalNode4"],
  "signature": "AliceSignatureDEF456"
}
```

---

### 2. DAG Query Message Example

A DAG query message promises the retrieval of events that match certain criteria rather than issuing a simple retrieval request. For example, Bob might query for all events since a specific timestamp.

**Example JSON:**

```json
{
  "op": "query",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:10:00Z",
  "target": "worldline123",
  "criteria": {
    "since": "2023-10-01T10:00:00Z"
  },
  "claims": [
    {"description": "Retrieve all events recorded after the provided timestamp"}
  ],
  "signature": "BobQuerySignatureXYZ"
}
```

---

### 3. DAG Subscription Message Example

A subscription message is a promise by the agent to receive notifications about certain events or operations on a worldline. In this case, Bob subscribes to "insert" events on a worldline.

**Example JSON:**

```json
{
  "op": "subscribe",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:15:00Z",
  "target": "worldline123",
  "criteria": {
    "filter": "insert"
  },
  "claims": [
    {"description": "Subscribe to insertion events on the worldline"}
  ],
  "signature": "BobSubsSignature456"
}
```

---

## Consistency and Review of the Model

- **Multiple Worldlines and Branching:**  
  The architecture supports parallel worldlines capable of branching and merging. A single message may encompass edits spanning multiple worldlines.

- **Promise-Based Communication:**  
  All operations, including edits, queries, and subscriptions, are framed as promises using structured CWT claims. This ensures that every claim is a verified promise instead of a simple request for permission.

- **Terminology Consistency:**  
  - "Event" is uniformly used to denote the immutable DAG leaf.
  - "Message" consistently refers to the edit operation that carries promises.  
  This helps prevent ambiguity.

- **Replayability:**  
  With every edit including previous internal node hashes, the entire history is fully replayable. This facilitates state reconstruction, auditability, and debugging.

- **CWT Claims Compliance:**  
  All examples ensure that promise-based operations are expressed using correctly structured CWT claims, meeting relevant RFC guidelines for CWT and JWT messages.

- **Merkle DAG Integrity:**  
  By not including previous event hashes in leaves and rather relying on internal nodes for linking, the system mirrors proven version control practices similar to Git.

---

## Conclusion

The worldline completion model provides a robust, verifiable methodology for managing events in a messaging system. By using a Merkle DAG combined with promise-based CWT claims, the system supports complex editing operations such as branching, merging, and multi-worldline modifications while ensuring the integrity, replayability, and auditability of every event. This comprehensive approach enables agents like Alice and Bob to interact with the system in a clear, secure, and consistent manner.
```
EOF_/home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md