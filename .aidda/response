Below is one way to update hello.go so that when you click the button the WebAssembly code opens (or creates) an IndexedDB database, writes a string value to an object store, and then retrieves that same value to display it on the page. (In a real application you would add proper error handling and perhaps “upgrade” logic for subsequent database versions.) 

Below is the updated hello.go file:

--------------------------------------------------
package main

import (
	"syscall/js"
)

func main() {
	// Get the global document object.
	document := js.Global().Get("document")

	// Create a button element.
	button := document.Call("createElement", "button")
	button.Set("innerHTML", "Store & Retrieve from IndexedDB")

	// Append the button to the body.
	document.Get("body").Call("appendChild", button)

	// Define the click event handler.
	clickHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		// Get IndexedDB from the global object.
		indexedDB := js.Global().Get("indexedDB")
		if indexedDB.IsUndefined() {
			p := document.Call("createElement", "p")
			p.Set("innerHTML", "IndexedDB is not supported in this browser.")
			document.Get("body").Call("appendChild", p)
			return nil
		}

		// Open (or create) a database called "MyDatabase" with version 1.
		request := indexedDB.Call("open", "MyDatabase", 1)

		// onupgradeneeded event handler to create the object store.
		var onUpgrade js.Func
		onUpgrade = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
			// Get the database from the request.
			db := request.Get("result")
			// Create an object store named "greetings".
			// (In a production app you might want to check if it already exists.)
			db.Call("createObjectStore", "greetings")
			// Clean up: remove the upgrade handler.
			request.Set("onupgradeneeded", js.Undefined())
			onUpgrade.Release()
			return nil
		})
		request.Set("onupgradeneeded", onUpgrade)

		// onsuccess event handler when the database is opened.
		var onSuccess js.Func
		onSuccess = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
			db := request.Get("result")
			// Start a read-write transaction on the "greetings" object store.
			tx := db.Call("transaction", "greetings", "readwrite")
			store := tx.Call("objectStore", "greetings")

			// Store a value "Hello, IndexedDB" with key "hello".
			putReq := store.Call("put", "Hello, IndexedDB", "hello")

			// Handler to be called when the put request succeeds.
			var onPutSuccess js.Func
			onPutSuccess = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
				// Now get the stored value back.
				getReq := store.Call("get", "hello")
				var onGetSuccess js.Func
				onGetSuccess = js.FuncOf(func(this js.Value, args []js.Value) interface{} {
					val := getReq.Get("result").String()
					// Append the retrieved value to the document as a paragraph.
					p := document.Call("createElement", "p")
					p.Set("innerHTML", "IndexedDB Value: "+val)
					document.Get("body").Call("appendChild", p)
					// Cleanup the get-success handler.
					getReq.Set("onsuccess", js.Undefined())
					onGetSuccess.Release()
					return nil
				})
				getReq.Set("onsuccess", onGetSuccess)
				// Cleanup the put-success handler.
				putReq.Set("onsuccess", js.Undefined())
				onPutSuccess.Release()
				return nil
			})
			putReq.Set("onsuccess", onPutSuccess)
			// Cleanup the onsuccess handler for the open request.
			request.Set("onsuccess", js.Undefined())
			onSuccess.Release()
			return nil
		})
		request.Set("onsuccess", onSuccess)

		// (Optional) You could also define onerror handlers, etc.

		return nil
	})
	// Add the click event listener to the button.
	button.Call("addEventListener", "click", clickHandler)
	// We do not release clickHandler here since we want it to be live throughout the app.

	// Prevent the Go program from exiting.
	select {}
}

--------------------------------------------------

How It Works:

1. When the button is clicked, the click handler is invoked.
2. The handler uses js.Global() to access the IndexedDB interface and calls open("MyDatabase", 1) to open or create a database.
3. In the onupgradeneeded callback the code creates a new object store named "greetings" if needed.
4. In the onsuccess callback the code starts a transaction on "greetings", writes the string "Hello, IndexedDB" with key "hello" (using put), and then immediately issues a get request for the same key.
5. Once the value is retrieved (via the get request’s onsuccess handler), it is appended to the document as a new paragraph.

This example should be compiled using:
  GOOS=js GOARCH=wasm go build -o hello.wasm hello.go

and run within your existing HTML/JS setup as described in the README. Enjoy exploring IndexedDB with WebAssembly and Go!