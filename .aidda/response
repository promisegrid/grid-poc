File: /home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md
```markdown
# Worldline Completion Model in Messaging Systems

The worldline completion model offers an innovative approach to managing events in a messaging system by leveraging a Merkle DAG structure to create a complete, verifiable history of events. Every message is a Directed Acyclic Graph (DAG) edit operation—a promise (in Promise Theory style as described by Mark Burgess) that asserts and validates the intended update to one or more worldline(s). This document explains the worldline data structure, how it could be implemented, and reviews examples of DAG edit, query, and subscription messages expressed as CWT claims. In particular, it clarifies key relationships between messages, DAG nodes, promises, and events.

---

## Overview of the Worldline Completion Model

Key aspects of the model include:

- **Multiple Worldlines with Branching and Merging:**  
  The architecture supports multiple concurrent worldlines. These worldlines may branch or merge; a single event can contribute to several worldlines simultaneously.

- **Message as a DAG Edit Operation and Promise:**  
  Every message is a directed edit operation on the DAG that carries one or more promises expressed as structured CWT claims. Importantly:
  - An agent may only promise about its own behavior and cannot enforce promises on the behavior of others.
  - A promise is not a request for action—it is an agent’s assertion that the proposed DAG edit operation is valid and will lead to a consistent worldline state when applied in the proper context.
  
- **Merkle DAG Architecture:**  
  - **Events in Leaves:**  
    Events, recorded as leaves in the DAG, represent immutable historical records. They intentionally do not include references to previous events, avoiding redundancy.
    
  - **Internal Nodes as Edit Logs:**  
    Internal nodes function as logs containing the promise messages (edit operations) that modify one or more worldlines. They store the cryptographic hashes of their child nodes, ensuring that the history remains verifiable and tamper-proof.
    - Each message is a compound promise assembled from one or more CWT claims. Every claim details a specific edit on the Merkle DAG.
  
- **Unified Language for Editing, Querying, and Subscriptions:**  
  The system employs a single language for all DAG operations. Whether the operation is an edit, query, or subscription, the command is embedded as a structured claim, ensuring consistency and verifiability across all operations.

- **Replayability and Integrity:**  
  Every edit operation carries sufficient context (such as previous internal node hashes) to allow for replaying the entire message history. This guarantees that the state of each worldline is reconstructable in a deterministic manner, even when some referenced nodes are temporarily inaccessible.

- **Worldline Scoping:**  
  The model is flexible enough to be implemented as a single unified DAG covering all known worldlines, or as multiple DAGs (one per worldline) that may eventually merge. The choice depends on desired scalability, performance, and operational specifics.

---

## Relationships between Messages, DAG Nodes, Promises, and Events

This section further clarifies the inter-relationships between the core components:

- **Messages as Edit Operations and Promises:**  
  Each message is an instruction to modify the DAG and simultaneously acts as a promise—an assertion by an agent that the requested change (e.g., insertion, deletion, or reordering) is valid. These promise statements follow Burgess-style Promise Theory:
  - Agents can only promise regarding actions they can control.
  - Promises are self-contained commitments, not imperatives for action.
  - The integrity of the DAG depends on these promise messages being correctly validated by their associated CWT claims.

- **DAG Nodes – Leaves and Internal Nodes:**  
  - **Leaf Nodes (Events):**  
    Leaves capture events as immutable records. They represent a finalized portion of the history that has been cryptographically sealed by previous promises.
  
  - **Internal Nodes (Edit Logs):**  
    Internal nodes maintain a log of promises (messages) that have edited one or more worldlines. By storing the hashes of their child nodes, they ensure the consistency and auditability of the entire DAG. This design supports complete replayability since the full sequence of operations is stored and can be revalidated.

- **Promises via CWT Claims:**  
  The promises are expressed as CWT claims, each one describing an intended edit to the Merkle DAG. A CWT functions as a container for one or more promises rather than being a promise by itself. This allows for compound operations where multiple related changes can be securely bundled.

- **Events as Immutable Records:**  
  Once a message is successfully applied, its effects are recorded as an event (a leaf node). Events are final and immutable, ensuring that the historical record cannot be tampered with once created.

- **Handling Inaccessible Nodes:**  
  The design anticipates scenarios where some referenced leaves or internal nodes might not be accessible in real time. Inclusion of prior internal node hashes in each message provides a mechanism for integrity checking. When missing components become available, the system can verify that the historical context remains intact.

- **Ensuring a Valid Worldline Representation:**  
  By combining promise-based messages for edits with immutable events stored in a Merkle DAG, the system ensures that at any point, the DAG represents a verifiable, valid state of one or more worldlines. This approach guarantees that the complete history can be replayed, audited, and trusted.

---

## Worldline Data Structure Example in Go

A representative Go-style structure for an event within a worldline is shown below:

```go
type WorldlineEvent struct {
    Timestamp time.Time // The creating agent’s local timestamp.
    Agent     string    // Identifier of the agent (e.g., "Alice" or "Bob").
    Payload   []byte    // Contains one or more PT-style promises expressed as CWT claims.
    Signature []byte    // Digital signature from the agent to validate the promise.
}
```

### Merkle DAG Essentials

- **Leaf Nodes (Events):**  
  Store the payload, timestamp, and signature without linking directly to previous events.
  
- **Internal Nodes (Edit Logs):**  
  Log the sequence of messages (edit operations) by containing the ordered hashes of child nodes. This structuring mirrors practices found in version control systems (such as Git) and ensures tamper resistance.

---

## Example Scenarios

### 1. DAG Edit Message Examples

Edit messages serve as promises to modify one or more worldlines.

#### a. Insert Operation

Alice sends a message to insert a new event at a specific position. The message includes prior internal node hashes to provide context for the edit.

**Example JSON:**

```json
{
  "op": "insert",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:05:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Insert event 'Hello' as an initial greeting", "detail": "Welcome message"}
    ]
  },
  "prevHashes": ["hash_internalNode1", "hash_internalNode2"],
  "signature": "AliceSignatureABC123"
}
```

#### b. Delete Operation

Bob issues a deletion message to remove an outdated event. The message includes necessary context for verifying the deletion.

**Example JSON:**

```json
{
  "op": "delete",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:20:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Delete event 'Obsolete'", "detail": "Removing outdated information"}
    ]
  },
  "prevHashes": ["hash_internalNode3"],
  "signature": "BobSignatureXYZ789"
}
```

#### c. Reorder Operation

Alice proposes a reorder of events within a worldline. The new order is verifiable through the inclusion of prior internal node hashes.

**Example JSON:**

```json
{
  "op": "reorder",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:30:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"description": "Reorder events to prioritize recent updates", "detail": "Moving update event up"}
    ]
  },
  "prevHashes": ["hash_internalNode4"],
  "signature": "AliceSignatureDEF456"
}
```

---

### 2. DAG Query Message Example

A query message promises the retrieval of events that match specified criteria rather than merely requesting data. For instance, Bob might query for all events since a specific timestamp.

**Example JSON:**

```json
{
  "op": "query",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:10:00Z",
  "target": "worldline123",
  "criteria": {
    "since": "2023-10-01T10:00:00Z"
  },
  "claims": [
    {"description": "Retrieve all events recorded after the provided timestamp"}
  ],
  "signature": "BobQuerySignatureXYZ"
}
```

---

### 3. DAG Subscription Message Example

A subscription message is a promise that an agent makes to receive notifications for specified types of events. Here, Bob subscribes to insertion events on the worldline.

**Example JSON:**

```json
{
  "op": "subscribe",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:15:00Z",
  "target": "worldline123",
  "criteria": {
    "filter": "insert"
  },
  "claims": [
    {"description": "Subscribe to insertion events on the worldline"}
  ],
  "signature": "BobSubsSignature456"
}
```

---

## Conclusion

The worldline completion model provides a robust, verifiable methodology for managing events in a messaging system. By leveraging a Merkle DAG structure and promise-based CWT claims, the system ensures that every message (i.e., edit operation) is a cryptographically verifiable promise that preserves the integrity of the worldline history. This approach supports complex operations such as branching, merging, and multi-worldline editing while maintaining replayability, auditability, and consistency. Agents like Alice and Bob can interact with the system in a secure and transparent manner, with clear distinctions between immutable events and the mutable promises that edit them.
```
EOF_/home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md