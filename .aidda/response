<think>
Okay, I need to reconcile the concepts of worldline and scenario tree
in the context of the PromiseGrid wire protocol. Let me start by
understanding both terms.

A worldline, as per the user's description, is a sequence of events
and states along an axis like time. It uses a Merkle DAG to allow
agents to add events without changing existing hashes. The key here is
that events can be part of multiple worldlines, enabling flexibility
and history preservation.

A scenario tree, from the provided search results, models decisions
and probabilistic outcomes. Each node represents a decision or chance
event, with branches showing possible outcomes and their
probabilities. The Lindo example [1][7] shows a tree with stages,
events, and probabilities, which helps in calculating expected
outcomes.

The user wants to integrate probabilities and alternate paths (like
scenario trees) into the worldline model. The challenge is to
represent possible branches (scenarios) within the Merkle DAG
structure, where each branch has probabilities and weight multipliers.

Looking at the existing wire.md, the scenario tree is represented as
nested lists with event CID, state CID, probability, weight, and
nested branches. However, the user noted issues: CIDs should be
binary, not strings, and the probability math is incorrect.

First, correcting CID representation. The wire.md uses full base32
strings for CIDs in map keys, but according to DAG-CBOR rules, map
keys must be strings. However, in the scenario tree structure, they're
using lists, not maps, so maybe binary CIDs are acceptable there.
Wait, the user's comment says "CIDs should be binary" in the example.
So in the scenario tree lists, event and state identifiers should be
binary CIDs (tag 42), not strings. The current example uses strings,
which is wrong.

Next, probability handling. The current example in wire.md has
probabilities as floats, but the user's test cases mention using
fixed-point integers for determinism. Floating points can cause
hashing issues due to rounding. So probabilities should be integers
representing fractions, e.g., 0.65 as 6500 with a denominator of
10000.

The trust metric calculation in wire.md's Python code multiplies
weight by (actual - predicted), but the user notes this rewards
setting probabilities to 0. The correct approach might be to use a
proper scoring rule, like Brier score, where the loss is (actual -
predicted)^2. The current code's trust metric is flawed.

Also, the scenario tree's weight multiplier applies to subsequent
branches. The structure in wire.md shows each branch has a weight
affecting nested branches. That part seems correct but needs
verification.

In the COSE_Sign1 example, the payload includes "tree" as a CID
string. Since the scenario tree is part of the payload, it should be
embedded directly or referenced via a binary CID. The current example
uses a string, which might not be correct if the tree is nested within
the payload.

Another point is the use of lists instead of maps in the scenario tree
to comply with DAG-CBOR's map key constraints. The current design uses
nested lists, which is correct to avoid map key issues.

Now, reconciling worldlines and scenario trees: each worldline is a
path through the scenario tree. The Merkle DAG allows sharing nodes
across different worldlines. Each node in the DAG can be part of
multiple branches (scenarios), enabling agents to propose alternate
futures without altering existing data.

To implement this, each event node in the DAG should link to possible
subsequent events (branches) with their probabilities and weights. The
Merkle structure ensures that changes in branches don't affect leaf
hashes, maintaining data integrity.

Testing considerations include ensuring CIDs are correctly encoded,
probabilities are fixed-point, and the trust metric uses a proper
scoring rule. The wire-test.md needs updates to reflect these checks,
like verifying CID formats and probability ranges.

In summary, the corrections needed are:

1. Use binary CIDs (tag 42) in scenario tree lists, not strings.
2. Represent probabilities as fixed-point integers.
3. Correct the trust metric calculation to use a proper scoring rule.
4. Ensure the COSE payload correctly embeds or references the scenario tree.
5. Update test cases to check these aspects.

I'll proceed to modify the wire.md and wire-test.md files accordingly,
ensuring compliance with DAG-CBOR, correct CID usage, and accurate
probability handling.
</think>

File: /home/stevegt/lab/grid-poc/x/wire/wire.md
```markdown
# PromiseGrid Wire Protocol Specification

This specification document defines the PromiseGrid wire protocol, a
system that leverages CBOR, COSE, and IPLD/DAG-CBOR technologies to
securely transmit signed assertions of state transitions in a
decentralized network. The protocol models an infinite state machine
as a probabilistic scenario tree where each branch contains:

1. Binary CIDs referencing events/states (CBOR tag 42)
2. Fixed-point probability (16-bit integer representing 0.0-1.0 scaled by 65535)
3. 16-bit weight multiplier affecting subsequent branches
4. Nested branches maintaining Merkle structural integrity

## 1. Introduction

PromiseGrid enables decentralized agents to assert conditional state
transitions across multiple possible worldlines. Each signed assertion
specifies: 

- Concrete event→state transitions using content-addressed IPLD nodes  
- Probabilistic branching with weight-adjusted trust propagation  
- Merkle-DAG structure allowing partial validation and cross-worldline referencing

## 2. Protocol Message Design

### 2.1 scenario Tree Structure

```cbor
[
  # Event CID (binary CBOR tag 42)
  42(h'01e5b3...'),  
  
  # State CID (binary CBOR tag 42)  
  42(h'8a4f6d...'),
  
  # Probability as fixed-point (0.65 = 42598/65535)
  42598,  
  
  # Weight multiplier (1.2x = 7864/8192)
  7864,
  
  # Nested branches
  [
    [
      42(h'd3a9...'), 
      42(h'fe12...'),
      58982, 
      8192,
      []
    ]
  ]
]
```

### 2.2 Deterministic Encoding Rules

1. **CIDs**: Always CBOR tag 42 with binary multihash
2. **Probabilities**: uint16 where 0xFFFF = 1.0
3. **Weights**: uint16 where 8192 = 1.0x (Q12 fixed-point)
4. **Ordering**: Branches sorted by CID byte values

## 3. Trust Metric Algorithm

```python
def update_trust(prior, actual, predicted, weight):
    # Brier score with weight scaling
    loss = (actual - predicted/65535)**2
    return prior * (1 - weight/8192 * loss) 
```

## 4. Signature & Validation

```cbor
COSE_Sign1(
  protected: <<{
    1: -7,  # ES256
    15: {    # CWT Claims
      "iss": 42(h'...'),  # Issuer CID
      "seq": 42(h'...')   # Previous state CID  
    }
  }>>,
  payload: <<[
    42(h'...'), # Protocol version CID
    42(h'...'), # Root scenario tree CID
    42(h'...')  # Pinning contract CID
  ]>>,
  signature: h'3045...'
)
```

# Compliance Requirements

- All Merkle links must use binary CID tag 42  
- Probabilities ≤65535 (0xFFFF) with 0xFFFF=1.0
- Weights ≤16384 (0x4000) with 8192=1.0x
- Nested depth ≤256 to prevent stack overflows
- Signature covers protocol CID + tree CID + pinning CID
```

File: /home/stevegt/lab/grid-poc/x/wire/wire-test.md
```markdown
# PromiseGrid Wire Protocol Compliance Tests

### Structural Validation
1. Verify all CIDs use CBOR tag 42 with binary multihash
   - Reject: String CIDs, truncated formats, missing tags
2. Confirm scenario tree depth ≤256 levels
   - Test: 257-level nested structure must fail
3. Check probability/weight ranges:
   - Valid: 0 ≤ probability ≤65535
   - Valid: 0 ≤ weight ≤16384  
   - Invalid: probability=65536 → reject
4. Ensure branch ordering by CID byte values
   - Test: Unsorted branches must fail validation

### Semantic Validation
5. Validate Merkle links resolve to correct content
   - Mock test: CID → {"type":"Event","timestamp":1672531200}
6. Verify trust metric calculations
   - Input: prior=0.5, actual=1.0, predicted=0.8 (52428), weight=1.0 (8192)
   - Expected: 0.5 * (1 - 1*(0.2)^2) = 0.48
7. Test signature coverage:
   - Modify protocol CID → invalid signature
   - Modify tree CID → invalid signature
   - Modify pinning CID → invalid signature

### Edge Cases
8. Zero probability branch (prob=0)
   - Must not affect trust metrics
9. Maximum weight multiplier (16384 = 2.0x)
   - Verify trust loss capped at 2x base rate
10. Empty scenario tree ([] → root state)
    - Valid initialization message
11. Duplicate CIDs in branches
    - Allowed but must be sorted properly

### Fuzz Testing
12. Invalid CBOR structures 
    - Malformed arrays → parse error
13. Extreme nested depths
    - 256 valid, 257 invalid
14. Integer overflows 
    - prob=65535 + 1 → reject
15. Non-CID types in tree
    - String → reject, tag 42 required
```

<references>
[1] https://www.lindo.com/doc/online_help/lingo18_0/scenario_tree.htm
[2] https://worldline.com/en-ca/home/main-navigation/resources/resources-hub/blogs/the-why-behind-reconciling
[3] https://math.usu.edu/schneit/StatsStuff/Probability/probability7.html
[4] https://scottaaronson.blog/?p=6541
[5] https://arxiv.org/html/2403.00218v1
[6] https://www.cointab.net/business/anz-worldline-payment-gateway-reconciliation/
[7] https://lindo.com/doc/online_help/lingo20_0/scenario_tree.htm
[8] https://nibmehub.com/opac-service/pdf/read/Structure%20and%20Interpretation%20of%20Computer%20Programs%20-.pdf
[9] https://pmc.ncbi.nlm.nih.gov/articles/PMC10021014/
[10] https://people.eecs.berkeley.edu/~jordan/papers/variational-intro.pdf
[11] http://ndl.ethernet.edu.et/bitstream/123456789/8271/1/182.pdf.pdf
[12] https://www.utdallas.edu/~nrr150130/gmbook/bayes.html
[13] https://pmc.ncbi.nlm.nih.gov/articles/PMC9165295/
[14] https://sicp.sourceacademy.org/sicpjs.pdf
[15] http://etheses.lse.ac.uk/1609/1/U150220.pdf
[16] https://library.oapen.org/bitstream/id/bd075f0a-fbba-4b0f-a5f3-820888d84e91/9781000635201.pdf
</references>
