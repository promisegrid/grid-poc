---FILE-START filename="/home/stevegt/lab/grid-poc/x/sim3.5/sim3_5.go"---
package main

import (
	"fmt"
	"strings"
	"sync"
)

// Global list of agents and the exchange kernel.
var allAgents []*Agent
var Exchange *Kernel

// Kernel represents the exchange that matches orders from buyers and
// sellers. It maintains order books for bids and asks. In this open market
// model, agents submit BID and ASK orders identified by unique order IDs.
// When orders are matched, the kernel acts as the exchange, executing a
// balanced doubleâ€entry transaction. In each trade, one party debits an asset
// while crediting a liability, ensuring that the fundamental accounting
// equation Assets = Liabilities + Equity is satisfied. In addition, each agent
// issues its own personal currency. The kernel maintains a ledger of these
// currencies and verifies that each agent's personal currency is unique.
type Kernel struct {
	agents             map[string]*Agent
	bids               []Message
	asks               []Message
	personalCurrencies map[string]bool
	mu                 sync.Mutex
}

// NewKernel creates a new Kernel (exchange) instance.
func NewKernel() *Kernel {
	return &Kernel{
		agents:             make(map[string]*Agent),
		bids:               []Message{},
		asks:               []Message{},
		personalCurrencies: make(map[string]bool),
	}
}

// RegisterAgent registers an agent with the exchange. It enforces that each
// agent's personal currency is unique.
func (k *Kernel) RegisterAgent(agent *Agent) {
	k.mu.Lock()
	defer k.mu.Unlock()
	// Ensure the agent's personal currency is unique.
	if _, exists := k.personalCurrencies[agent.PersonalCurrency]; exists {
		fmt.Printf("Error: personal currency %s already registered\n",
			agent.PersonalCurrency)
		return
	}
	k.personalCurrencies[agent.PersonalCurrency] = true
	k.agents[agent.ID] = agent
}

// SubmitOrder processes an order (BID or ASK) submitted by an agent.
// It attempts to match the order with an opposing order in the order book.
// For a trade to match, the Message.Symbol field must indicate the target
// personal currency, and if the GoodSymbol field is provided then both orders
// must match on GoodSymbol and GoodQty as well. When a match is found, the trade
// is executed as a bilateral swap: the buyer receives the seller's personal
// currency as an asset while incurring a liability in his own currency, and vice-
// versa for the seller. A trade confirmation message is then sent to both
// participants.
func (k *Kernel) SubmitOrder(order Message) {
	k.mu.Lock()
	defer k.mu.Unlock()

	// Validate that the GoodSymbol field is not empty
	// and GoodQty is non-zero.
	if order.GoodSymbol == "" || order.GoodQty == 0 {
		fmt.Printf("Error: Order %s must have non-empty GoodSymbol and "+
			"non-zero GoodQty\n", order.OrderID)
		return
	}

	switch order.Type {
	case "BID":
		// Add the bid order to the order book.
		k.bids = append(k.bids, order)
		// Attempt to match with an existing ask order.
		for _, ask := range k.asks {
			// Check if the good or service is involved; if either order
			// specifies a GoodSymbol then both must match in GoodSymbol
			// and GoodQty.
			if order.GoodSymbol != "" || ask.GoodSymbol != "" {
				if order.GoodSymbol != ask.GoodSymbol ||
					order.GoodQty != ask.GoodQty {
					continue
				}
			}
			if order.Amount >= ask.Amount &&
				order.Symbol == ask.Symbol {
				// A match is found; execute trade.
				tradePrice := order.Amount
				buyer := k.agents[order.From]
				seller := k.agents[ask.From]
				// For the buyer:
				//   Debit asset: seller's personal currency.
				//   Credit liability: buyer's personal currency.
				buyer.Assets[order.Symbol] += tradePrice
				buyer.Liabilities[buyer.PersonalCurrency] += tradePrice
				// For the seller:
				//   Debit asset: buyer's personal currency.
				//   Credit liability: seller's personal currency.
				seller.Assets[buyer.PersonalCurrency] += tradePrice
				seller.Liabilities[seller.PersonalCurrency] += tradePrice
				// If a good or service is being exchanged, update goods balance.
				if order.GoodSymbol != "" {
					buyer.Goods[order.GoodSymbol] += order.GoodQty
					seller.Goods[order.GoodSymbol] -= order.GoodQty
				}
				// Create a confirmation message.
				confirmMsg := Message{
					Type:       "CONFIRM",
					Amount:     tradePrice,
					Symbol:     order.Symbol,
					From:       "Exchange",
					GoodSymbol: order.GoodSymbol,
					GoodQty:    order.GoodQty,
					OrderID:    order.OrderID,
				}
				buyer.ReceiveConfirm(confirmMsg)
				seller.ReceiveConfirm(confirmMsg)
				// Remove the matched ask and bid orders using their order IDs.
				k.removeAskOrder(ask.OrderID)
				k.removeBidOrder(order.OrderID)
				return
			}
		}
	case "ASK":
		// Add the ask order to the order book.
		k.asks = append(k.asks, order)
		// Attempt to match with an existing bid order.
		for _, bid := range k.bids {
			// Check for matching goods if specified.
			if order.GoodSymbol != "" || bid.GoodSymbol != "" {
				if order.GoodSymbol != bid.GoodSymbol ||
					order.GoodQty != bid.GoodQty {
					continue
				}
			}
			if bid.Amount >= order.Amount &&
				bid.Symbol == order.Symbol {
				tradePrice := bid.Amount
				buyer := k.agents[bid.From]
				seller := k.agents[order.From]
				// For the buyer:
				//   Debit asset: seller's personal currency.
				//   Credit liability: buyer's personal currency.
				buyer.Assets[order.Symbol] += tradePrice
				buyer.Liabilities[buyer.PersonalCurrency] += tradePrice
				// For the seller:
				//   Debit asset: buyer's personal currency.
				//   Credit liability: seller's personal currency.
				seller.Assets[buyer.PersonalCurrency] += tradePrice
				seller.Liabilities[seller.PersonalCurrency] += tradePrice
				// If a good or service is being exchanged, update goods balance.
				if order.GoodSymbol != "" {
					buyer.Goods[order.GoodSymbol] += order.GoodQty
					seller.Goods[order.GoodSymbol] -= order.GoodQty
				}
				confirmMsg := Message{
					Type:       "CONFIRM",
					Amount:     tradePrice,
					Symbol:     order.Symbol,
					From:       "Exchange",
					GoodSymbol: order.GoodSymbol,
					GoodQty:    order.GoodQty,
					OrderID:    order.OrderID,
				}
				buyer.ReceiveConfirm(confirmMsg)
				seller.ReceiveConfirm(confirmMsg)
				// Remove the matched bid and ask orders using their order IDs.
				k.removeBidOrder(bid.OrderID)
				k.removeAskOrder(order.OrderID)
				return
			}
		}
	}
}

// removeBidOrder removes a bid order from the order book identified by the
// given order ID.
func (k *Kernel) removeBidOrder(orderID string) {
	for i, bid := range k.bids {
		if bid.OrderID == orderID {
			k.bids = append(k.bids[:i], k.bids[i+1:]...)
			return
		}
	}
}

// removeAskOrder removes an ask order from the order book identified by the
// given order ID.
func (k *Kernel) removeAskOrder(orderID string) {
	for i, ask := range k.asks {
		if ask.OrderID == orderID {
			k.asks = append(k.asks[:i], k.asks[i+1:]...)
			return
		}
	}
}

// Message represents an order or trade confirmation in the exchange.
// The message type can be "BID", "ASK", or "CONFIRM". Each order message is
// identified by a unique OrderID. The Symbol field indicates the personal
// currency being traded. In addition, the GoodSymbol field indicates the
// specific good or service being exchanged and the GoodQty field specifies
// the quantity of the good or service being exchanged.
type Message struct {
	OrderID    string  // Unique identifier for the order
	Type       string  // "BID", "ASK", or "CONFIRM"
	Amount     float64 // Order amount or confirmed trade price
	Symbol     string  // Target personal currency (e.g., seller's currency)
	From       string  // Agent ID that submitted the order (or "Exchange")
	GoodSymbol string  // Indicates the specific good or service being exchanged
	GoodQty    float64 // Quantity of the good or service being exchanged
}

// String returns a string representation of the Message, including all fields.
func (m Message) String() string {
	return fmt.Sprintf("OrderID: %s, Type: %s, Amount: %.2f, Symbol: %s, "+
		"From: %s, GoodSymbol: %s, GoodQty: %.2f",
		m.OrderID, m.Type, m.Amount, m.Symbol, m.From, m.GoodSymbol, m.GoodQty)
}

// Agent represents a market participant. Agents hold their own balance
// sheets that display assets, liabilities, and goods. The balance sheet
// follows the double-entry accounting model where Assets = Liabilities + Equity.
// In addition, each agent issues its own personal currency used to transact on
// the exchange.
type Agent struct {
	ID               string
	PersonalCurrency string
	Assets           map[string]float64 // Ledger of assets by account name.
	Liabilities      map[string]float64 // Ledger of liabilities by account name.
	Goods            map[string]float64 // Ledger of goods and services.
}

// PrintBalanceSheet prints the agent's current balance sheet, showing their
// assets, liabilities, goods, and computed equity (Assets - Liabilities).
func (a *Agent) PrintBalanceSheet() {
	totalAssets := 0.0
	totalLiabilities := 0.0

	assetsStr := ""
	for acct, amt := range a.Assets {
		assetsStr += fmt.Sprintf("%s: %.2f  ", acct, amt)
		totalAssets += amt
	}

	liabStr := ""
	for acct, amt := range a.Liabilities {
		liabStr += fmt.Sprintf("%s: %.2f  ", acct, amt)
		totalLiabilities += amt
	}

	goodsStr := ""
	for good, qty := range a.Goods {
		goodsStr += fmt.Sprintf("%s: %.2f  ", good, qty)
	}

	equity := totalAssets - totalLiabilities
	fmt.Printf("Balance Sheet for %s -> Assets: [%s] Liabilities: [%s] "+
		"Goods: [%s] Equity: %.2f\n", a.ID, assetsStr, liabStr,
		goodsStr, equity)
}

// SubmitOrder allows an agent to submit an order (BID or ASK) to the exchange.
// The order must include a unique OrderID. The Symbol field should indicate the
// target personal currency for the transaction. The GoodSymbol field and GoodQty
// must be provided and indicate the specific good or service being exchanged.
func (a *Agent) SubmitOrder(order Message) {
	fmt.Printf("%s submits %s order (%s)\n", a.ID, order.Type, order.String())
	Exchange.SubmitOrder(order)
}

// ReceiveConfirm processes a trade confirmation message from the exchange.
func (a *Agent) ReceiveConfirm(msg Message) {
	fmt.Printf("%s receives CONFIRM: %s\n", a.ID, msg.String())
	a.PrintBalanceSheet()
}

// RunSimulation initializes four agents and simulates a basic open market trade.
// Each agent issues its own personal currency. In this simulation, the buyer
// (Alice) submits a BID order to acquire Dave's personal currency, and the seller
// (Dave) submits an ASK order offering his own currency. Both orders specify a
// GoodSymbol and GoodQty to indicate the specific good being exchanged.
// When the BID and ASK match, the exchange performs a balanced double-entry
// transaction: the buyer receives Dave's currency (asset) and incurs a liability
// in his own currency, while the seller receives Alice's currency (asset) and
// accrues a liability in his own currency.
func RunSimulation() (alice, bob, carol, dave *Agent) {
	// Initialize agents with empty ledger maps and assign unique personal
	// currencies. Here we set the personal currency to be the same as the ID.
	alice = &Agent{
		ID:               "Alice",
		PersonalCurrency: "Alice",
		Assets:           make(map[string]float64),
		Liabilities:      make(map[string]float64),
		Goods:            make(map[string]float64),
	}
	bob = &Agent{
		ID:               "Bob",
		PersonalCurrency: "Bob",
		Assets:           make(map[string]float64),
		Liabilities:      make(map[string]float64),
		Goods:            make(map[string]float64),
	}
	carol = &Agent{
		ID:               "Carol",
		PersonalCurrency: "Carol",
		Assets:           make(map[string]float64),
		Liabilities:      make(map[string]float64),
		Goods:            make(map[string]float64),
	}
	dave = &Agent{
		ID:               "Dave",
		PersonalCurrency: "Dave",
		Assets:           make(map[string]float64),
		Liabilities:      make(map[string]float64),
		Goods:            make(map[string]float64),
	}

	// Initialize global agent list.
	allAgents = []*Agent{alice, bob, carol, dave}

	// Initialize the exchange kernel and register all agents.
	Exchange = NewKernel()
	for _, agent := range allAgents {
		Exchange.RegisterAgent(agent)
	}

	// Simulation: Alice (buyer) submits a BID order.
	// She wishes to acquire Dave's personal currency, so the Symbol is set to "Dave".
	// Both GoodSymbol and GoodQty are specified to indicate the specific good.
	bidMsg := Message{
		OrderID:    "BID1",
		Type:       "BID",
		Amount:     10.0,
		Symbol:     "Dave",
		From:       alice.ID,
		GoodSymbol: "Dave",
		GoodQty:    10.0,
	}
	alice.SubmitOrder(bidMsg)

	// Simulation: Dave (seller) submits an ASK order offering his own currency.
	// Both GoodSymbol and GoodQty are specified.
	askMsg := Message{
		OrderID:    "ASK1",
		Type:       "ASK",
		Amount:     10.0,
		Symbol:     "Dave",
		From:       dave.ID,
		GoodSymbol: "Dave",
		GoodQty:    10.0,
	}
	dave.SubmitOrder(askMsg)

	return alice, bob, carol, dave
}

func main() {
	fmt.Println(strings.Repeat("=", 70))
	fmt.Println("Starting Open Market Simulation")
	fmt.Println(strings.Repeat("=", 70))
	RunSimulation()
}
---FILE-END filename="/home/stevegt/lab/grid-poc/x/sim3.5/sim3_5.go"---


---FILE-START filename="/home/stevegt/lab/grid-poc/x/sim3.5/sim3_5_test.go"---
package main

import "testing"

// TestSimulationTrade verifies that a trade is executed in the open market
// simulation. In this test, Alice submits a BID order for 10 units, where she
// wishes to acquire Dave's personal currency. Dave submits an ASK order offering
// his personal currency. When the matching engine functions properly, the trade
// should execute at the buyer's bid price.
// For the buyer (Alice):
//   - Assets: the asset corresponding to "Dave" should increase by 10.
//   - Liabilities: the liability corresponding to "Alice" should increase by 10.
// For the seller (Dave):
//   - Assets: the asset corresponding to "Alice" should increase by 10.
//   - Liabilities: the liability corresponding to "Dave" should increase by 10.
func TestSimulationTrade(t *testing.T) {
	alice, _, _, dave := RunSimulation()

	expectedValue := 10.0

	// Check buyer's asset for target currency "Dave".
	buyerAsset := alice.Assets["Dave"]
	if buyerAsset != expectedValue {
		t.Errorf("Expected Alice asset for Dave to be %.2f, got %.2f",
			expectedValue, buyerAsset)
	}
	// Check buyer's liability for her own currency "Alice".
	buyerLiability := alice.Liabilities["Alice"]
	if buyerLiability != expectedValue {
		t.Errorf("Expected Alice liability for Alice to be %.2f, got %.2f",
			expectedValue, buyerLiability)
	}
	// Check seller's asset for "Alice" currency.
	sellerAsset := dave.Assets["Alice"]
	if sellerAsset != expectedValue {
		t.Errorf("Expected Dave asset for Alice to be %.2f, got %.2f",
			expectedValue, sellerAsset)
	}
	// Check seller's liability for his own currency "Dave".
	sellerLiability := dave.Liabilities["Dave"]
	if sellerLiability != expectedValue {
		t.Errorf("Expected Dave liability for Dave to be %.2f, got %.2f",
			expectedValue, sellerLiability)
	}
}
---FILE-END filename="/home/stevegt/lab/grid-poc/x/sim3.5/sim3_5_test.go"---