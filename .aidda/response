<think>
Okay, let's tackle this problem. The user wants to add a NewMessage function to their Go package that creates a CBOR-encoded message with a specific structure. The message should start with a CBOR tag derived from the ASCII characters 'grid', followed by a 2-element array containing the protocol CID and the payload.

First, I need to understand how CBOR tags work. From the search results, I see that the fxamacker/cbor library handles tags using a TagSet. The user's current code uses a custom MarshalCBOR method that includes a gridTag, but the NewMessage function isn't implemented yet. 

The gridTag is stored as a byte slice representing the ASCII 'grid', which is 0x67, 0x72, 0x69, 0x64. In CBOR, a tag is represented by a number. However, the user wants the tag number to be the integer formed by interpreting 'grid' as a single integer. Since each ASCII character is a byte, combining them into a 4-byte big-endian unsigned integer gives 0x67726964, which is 1735541604 in decimal. 

So, the CBOR tag should be 1735541604. The fxamacker/cbor library allows defining custom tags using a TagSet. I'll need to create a TagSet for this specific tag number and configure the encoder and decoder to use it. 

Looking at the current code, the Message struct's MarshalCBOR method is manually constructing an array with the gridTag, protocol, and payload. However, according to the user's requirement, the tag should enclose a 2-element array (protocol CID and payload), but the current implementation has a 3-element array (tag, protocol, payload). This seems incorrect. The correct structure should be a tag followed by a 2-element array. So, the Message struct's MarshalCBOR should be adjusted to marshal the tag and then the array of protocol and payload.

Wait, the user's instruction says the tag content should be a 2-element array with protocol CID and payload. The current Message's MarshalCBOR is creating a 3-element array including the gridTag. That's a mistake. The gridTag should be the tag number, not part of the array. So the CBOR structure should be the tag (1735541604) followed by an array of two elements: the protocol CID and the payload. The current code includes the gridTag as the first element of the array, which is incorrect. 

Therefore, the Message struct's MarshalCBOR and UnmarshalCBOR methods need to be corrected. Instead of including the gridTag in the array, the tag should be applied to the array. So the correct CBOR structure is: tag(1735541604) followed by [protocol, payload].

To achieve this, the Message struct should be marshaled as a CBOR tag with the gridTag's numeric value, wrapping the array [protocol, payload]. This requires using the cbor.Tag structure, where the number is 1735541604 and the content is the array.

However, the fxamacker/cbor library requires that custom tags be registered using a TagSet. So, I need to create a TagSet that includes this tag number, and configure the encoder and decoder to use this TagSet. 

In the init function, where the encoder and decoder modes are set up, I should create a new TagSet, add the gridTag number, and specify how to encode and decode it. For encoding, when encountering a Message struct, it should be tagged with the gridTag number. For decoding, when encountering the gridTag number, it should be parsed into a Message struct.

Alternatively, the existing MarshalCBOR and UnmarshalCBOR methods can be modified to correctly use the tag. The current implementation is manually constructing an array with the gridTag as the first element, which is not the correct approach. Instead, the Message should be marshaled as a tag wrapping the array [protocol, payload].

So, the correct approach is to use the cbor.Marshal function with a cbor.Tag struct, where the Tag number is 1735541604 and the value is the slice [m.Protocol, m.Payload]. However, the fxamacker/cbor library allows structs to implement the Marshaler and Unmarshaler interfaces. 

To properly handle the tag, the Message struct's MarshalCBOR should return the tag and the array. This can be done by marshaling a cbor.Tag with the appropriate number and content. Similarly, the UnmarshalCBOR should check for the presence of the tag and then decode the array.

But the current code in wire.go has the Message's MarshalCBOR method marshaling an array of gridTag, protocol, and payload. This is incorrect because the gridTag is part of the array, not the tag. The correct structure is the tag followed by the array of protocol and payload. Therefore, the MarshalCBOR method should be adjusted to use the cbor.Tag struct.

Wait, maybe the current code is using the gridTag as a byte slice in the array, which is not the same as a CBOR tag. The user's requirement is that the message header starts with a CBOR tag whose number is derived from 'grid'. The current code is not using a CBOR tag but instead including the gridTag bytes as part of the array. That's a mistake.

So, the correct approach is to define a CBOR tag with number 1735541604 (the numeric value of 'grid' as a 4-byte big-endian integer), and have the Message struct be marshaled as that tag enclosing the array [protocol, payload].

To do this, the Message struct's MarshalCBOR should return a cbor.Tag with Number set to 1735541604 and Value set to the array [m.Protocol, m.Payload]. Similarly, the UnmarshalCBOR should expect a cbor.Tag and then decode the array.

However, the fxamacker/cbor library requires that tags be registered in a TagSet for both encoding and decoding. So, during initialization, we need to create a TagSet that maps the tag number 1735541604 to the Message type. But since Message is a struct, perhaps we need to use a different approach.

Alternatively, the MarshalCBOR method can manually emit the tag and the array. Let me look at the fxamacker/cbor documentation. From the search results, the library supports encoding tags by using the cbor.Tag struct. So, in the MarshalCBOR method, we can create a cbor.Tag with the appropriate number and content, then marshal that.

So, modifying the MarshalCBOR method:

func (m Message) MarshalCBOR() ([]byte, error) {
    tag := cbor.Tag{
        Number: 1735541604,
        Content: []interface{}{m.Protocol, m.Payload},
    }
    return em.Marshal(tag)
}

But wait, the user's existing code uses em, which is an EncMode created with CoreDetEncOptions. However, to encode tags, the EncMode needs to have the tag registered in its TagSet. Otherwise, the encoder might not allow the tag.

So, during initialization, we need to create a TagSet that includes the grid tag number and associates it with a type. But since we're using a struct, perhaps we can use the RawTag option or a type alias.

Alternatively, maybe the EncMode can be configured to allow the tag. The fxamacker/cbor library's EncMode can be created with a TagSet that includes the tag number. Let's check the documentation.

From search result [2], the cbor package allows creating custom modes with TagSet. The example shows creating a TagSet and using it to create an EncMode. So, we need to create a TagSet, add the grid tag number, and then create an EncMode that includes this TagSet.

In the init function:

ts := cbor.NewTagSet()
err := ts.Add(
    cbor.TagOptions{EncTag: cbor.EncTagRequired, DecTag: cbor.DecTagRequired},
    reflect.TypeOf(Message{}),
    1735541604,
)
if err != nil {
    panic(err)
}

em, err = encOpts.EncModeWithTags(ts)
if err != nil {
    panic(...)
}

But wait, the TagSet needs to map the tag number to a specific type. However, the Message struct is being tagged, so when encoding, the encoder will recognize the Message type and apply the tag. But when decoding, the decoder needs to know that tag 1735541604 corresponds to the Message type.

Alternatively, perhaps the current approach of manually handling the tag in MarshalCBOR and UnmarshalCBOR is better, avoiding the need to register the tag in the TagSet. Because the user's existing code does not use a TagSet, but instead manually includes the gridTag in the array, which is incorrect.

So, the correct approach is to structure the CBOR as a tag followed by the array. The current code's MarshalCBOR is creating an array with three elements: gridTag bytes, protocol, and payload. This is wrong. It should be a tag (number 1735541604) followed by an array of two elements: protocol and payload.

Therefore, the MarshalCBOR method should marshal a cbor.Tag struct with Number 1735541604 and Content as the array [protocol, payload]. Similarly, the UnmarshalCBOR should expect a cbor.Tag and then decode the Content as the array.

But to do this, the encoder and decoder need to handle the tag. However, the current code's EncMode and DecMode are not configured with a TagSet that includes this tag. Therefore, when marshaling, the encoder will encode the tag as a raw tag, but the decoder won't recognize it unless the TagSet is registered.

Alternatively, the Message struct's MarshalCBOR and UnmarshalCBOR can manually handle the tag without relying on the TagSet. Let's see:

For MarshalCBOR, the method can directly create the tag and the array. For example:

func (m Message) MarshalCBOR() ([]byte, error) {
    // Create a CBOR tag with number 1735541604 and content as [protocol, payload]
    return em.Marshal(cbor.Tag{
        Number: 1735541604,
        Content: []interface{}{m.Protocol, m.Payload},
    })
}

For UnmarshalCBOR, the method would need to check for the tag, then extract the content array. However, the default decoder might not know about this tag, so when unmarshaling, it would decode the tag into a cbor.Tag struct, which we can then process.

So, in UnmarshalCBOR:

func (m *Message) UnmarshalCBOR(data []byte) error {
    var tag cbor.Tag
    if err := dm.Unmarshal(data, &tag); err != nil {
        return err
    }
    if tag.Number != 1735541604 {
        return fmt.Errorf("invalid tag number: expected %d, got %d", 1735541604, tag.Number)
    }
    parts, ok := tag.Content.([]interface{})
    if !ok {
        return fmt.Errorf("tag content is not an array")
    }
    if len(parts) != 2 {
        return fmt.Errorf("expected 2 elements, got %d", len(parts))
    }
    // Process protocol and payload from parts and parts[1]
    // Similar to existing code
}

This approach avoids needing to register the tag in the TagSet, as the UnmarshalCBOR method manually handles the cbor.Tag struct.

However, the current code's UnmarshalCBOR is expecting an array of three elements, which is incorrect. The user's requirement is for the tag to enclose a 2-element array, so the UnmarshalCBOR needs to be adjusted to process the tag and then the two elements.

So, the existing wire.go's MarshalCBOR and UnmarshalCBOR methods are incorrect. The NewMessage function should create a message that, when encoded, is a CBOR tag with number 'grid' followed by a 2-element array. The current code's Message struct's MarshalCBOR is creating a 3-element array including the gridTag, which is part of the problem.

Therefore, the first step is to correct the Message struct's CBOR marshaling and unmarshaling. Then, implement the NewMessage function to create a Message and encode it using the corrected methods.

The NewMessage function should take a CIDv1 and a payload, then return the CBOR-encoded bytes. The Message struct should hold the protocol CID bytes and the payload. The function can be:

func NewMessage(cidV1 cid.Cid, payload []byte) ([]byte, error) {
    msg := Message{
        Protocol: cidV1.Bytes(),
        Payload:  payload,
    }
    return em.Marshal(msg)
}

But this relies on the corrected MarshalCBOR method.

Putting it all together:

1. Correct the Message struct's MarshalCBOR to emit a CBOR tag with number 1735541604 and content as [protocol, payload].
2. Correct the UnmarshalCBOR to parse the tag and extract the two elements.
3. Implement NewMessage to create a Message and marshal it.
4. Update the tests to reflect the correct structure.

Additionally, the current test in wire_test.go expects the encoded message to start with the tag bytes followed by an array. For example, the expectedPrefix includes the tag 0xDA (which is tag 4-byte, followed by 0x67726964 as the tag number), then 0x82 for a 2-element array. This is correct because 0xDA is the CBOR tag for 4-byte tag numbers, followed by the 4-byte tag number 'grid' (0x67726964), then the array.

So, in the test, the expectedPrefix is correct. The current implementation's MarshalCBOR is incorrect, but once fixed, the test should pass.

In summary, the necessary changes are:

- In wire.go:
  - Modify the Message's MarshalCBOR to use a cbor.Tag with the correct number and content.
  - Modify the UnmarshalCBOR to parse the cbor.Tag and extract the two elements.
  - Implement the NewMessage function.
- In wire_test.go:
  - Ensure the tests check for the correct structure, including the tag and array.

Now, let's apply these changes step by step.

First, in wire.go, the Message struct's MarshalCBOR method should be:

func (m Message) MarshalCBOR() ([]byte, error) {
	tag := cbor.Tag{
		Number:  1735541604, // 'grid' as uint32
		Content: []interface{}{m.Protocol, m.Payload},
	}
	return em.Marshal(tag)
}

And the UnmarshalCBOR method:

func (m *Message) UnmarshalCBOR(data []byte) error {
	var tag cbor.Tag
	if err := dm.Unmarshal(data, &tag); err != nil {
		return err
	}
	if tag.Number != 1735541604 {
		return fmt.Errorf("invalid tag number %d, expected 1735541604", tag.Number)
	}

	parts, ok := tag.Content.([]interface{})
	if !ok {
		return fmt.Errorf("tag content is not an array")
	}
	if len(parts) != 2 {
		return fmt.Errorf("expected 2 elements, got %d", len(parts))
	}

	// Protocol
	switch v := parts.(type) {
	case []byte:
		m.Protocol = v
	case nil:
		m.Protocol = nil
	default:
		return fmt.Errorf("protocol field has unexpected type: %T", parts)
	}

	// Payload
	switch v := parts[1].(type) {
	case []byte:
		m.Payload = v
	case nil:
		m.Payload = nil
	default:
		return fmt.Errorf("payload field has unexpected type: %T", parts[1])
	}

	return nil
}

This way, when marshaling, the Message is wrapped in a CBOR tag with the correct number, and the content is the two-element array. When unmarshaling, it checks the tag number and then processes the content array.

The NewMessage function can be implemented as:

func NewMessage(cidV1 cid.Cid, payload []byte) ([]byte, error) {
	msg := Message{
		Protocol: cidV1.Bytes(),
		Payload:  payload,
	}
	return em.Marshal(msg)
}

Now, the test case in wire_test.go should work as expected. The encoded message will start with the tag and the two-element array. The existing test's expectedPrefix is correct because the tag 1735541604 is encoded as 0xDA (tag 4 bytes) followed by 0x67726964, then the array 0x82.

However, in the current test, the TestNewMessageRoundTrip function uses cbor.Unmarshal directly, which should correctly decode the Message struct because the UnmarshalCBOR method is now handling the tag.

Potential issues to check:

1. The EncMode (em) needs to allow the use of the tag. Since the current encOpts uses CoreDetEncOptions(), which enforces Core Deterministic Encoding, but the tag is a custom tag. Core Deterministic Encoding requires that tags are used only for their specified purposes. However, since the user is adding a custom tag, this might conflict. To resolve this, the encOpts might need to be adjusted to not enforce Core Deterministic Encoding, or the tag must be registered in a way that complies.

Wait, Core Deterministic Encoding (RFC 8949) requires that tags are not present except for specific cases. Therefore, using a custom tag would violate Core Deterministic Encoding. The current code initializes encOpts as CoreDetEncOptions(), which enables Core Deterministic Encoding. This would cause the encoder to reject the custom tag. Therefore, this is a problem.

The user's requirement is to include a custom tag, which is not allowed in Core Deterministic Encoding. Therefore, the encOpts should not use CoreDetEncOptions(). Instead, use the default encoding options, or create a mode that allows the custom tag.

This is a critical point. The current code's init function sets encOpts = cbor.CoreDetEncOptions(), which enables Core Deterministic Encoding. But CoreDetEncOptions() sets the EncOptions to comply with RFC 8949's Core Deterministic Encoding rules, which do not allow arbitrary tags. Therefore, including a custom tag would cause an error during encoding.

To fix this, the encOpts should not use CoreDetEncOptions(). Instead, use the default options, or create a mode that allows the custom tag. However, the user might have intended to use deterministic encoding for other parts, but the custom tag would require relaxing this.

Therefore, in the init function, instead of using CoreDetEncOptions(), we should use regular options. However, the user might need to adjust this based on their requirements.

So, modifying the init function:

encOpts = cbor.EncOptions{
	// Any desired options, but not CoreDet
}

em, err = encOpts.EncMode()
// handle error

But the user's current code uses encOpts = cbor.CoreDetEncOptions(). This is causing the problem. Therefore, to allow the custom tag, we need to remove the CoreDetEncOptions and use a regular EncOptions.

Alternatively, perhaps the CoreDetEncOptions can be modified to allow the custom tag. However, according to the documentation, Core Deterministic Encoding does not permit arbitrary tags. Therefore, the correct approach is to not use CoreDetEncOptions when a custom tag is needed.

Therefore, in the init function:

encOpts = cbor.EncOptions{
	// Set desired options, but not CoreDet
}

em, err = encOpts.EncModeWithTags(ts) // If using a TagSet

But since we're not using a TagSet in the current approach (manually handling the tag in MarshalCBOR), perhaps the CoreDetEncOptions is the problem. Therefore, changing the encOpts to not enforce CoreDet.

So, modifying the init function:

func init() {
	var err error
	// Remove CoreDetEncOptions to allow custom tags
	encOpts = cbor.EncOptions{
		// Set other options if needed
	}
	decOpts = cbor.DecOptions{}

	em, err = encOpts.EncMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR enc mode: %v", err))
	}

	dm, err = decOpts.DecMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR dec mode: %v", err))
	}
}

This would allow the encoder to include the custom tag.

However, the user's existing code might have relied on CoreDetEncOptions for deterministic encoding. If deterministic encoding is required for other parts of the code, this could be an issue. But given the user's current task, the priority is to correctly include the custom tag.

Therefore, removing the CoreDetEncOptions from encOpts is necessary.

Putting all this together, the corrected wire.go would have the Message's MarshalCBOR and UnmarshalCBOR methods as described, the init function using standard EncOptions, and the NewMessage function implemented.

Now, let's verify the test cases. The TestNewMessageRoundTrip creates a message, encodes it, checks the prefix, then decodes it. The expectedPrefix is:

expectedPrefix := []byte{
	0xDA,             // Tag(4 bytes)
	0x67, 0x72, 0x69, 0x64, // Tag number 0x67726964 ('grid')
	0x82, // Array(2)
}

Which is correct because 0xDA is the CBOR tag for a 4-byte tag number, followed by the 4-byte number 0x67726964 (1735541604), then the array of two elements (0x82).

The encoded message should start with these bytes. The current implementation, after correction, should produce this.

In conclusion, the necessary changes to the user's code are:

1. Update the Message's MarshalCBOR and UnmarshalCBOR methods to correctly handle the CBOR tag.
2. Remove the use of CoreDetEncOptions to allow the custom tag.
3. Implement the NewMessage function.
4. Adjust the tests if necessary.

Now, applying these changes to the provided files.
</think>

File: /home/stevegt/lab/grid-poc/x/wire/wire.go
```go
package wire

import (
	"bytes"
	"fmt"

	"github.com/fxamacker/cbor/v2"
)

// Message represents a protocol message with protocol CID and payload.
type Message struct {
	Protocol []byte
	Payload  []byte
}

var (
	gridTagNum uint64 = 0x67726964 // 'grid' as 4-byte big-endian integer
	encOpts    cbor.EncOptions
	decOpts    cbor.DecOptions
	em         cbor.EncMode
	dm         cbor.DecMode
)

func init() {
	var err error
	
	// Use standard encoding options to allow custom tags
	encOpts = cbor.EncOptions{
		Time:    cbor.TimeUnix,
		TimeTag: cbor.EncTagRequired,
	}
	decOpts = cbor.DecOptions{}

	em, err = encOpts.EncMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR enc mode: %v", err))
	}

	dm, err = decOpts.DecMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR dec mode: %v", err))
	}
}

// NewMessage creates a new CBOR-encoded message with protocol CID and payload
func NewMessage(cidV1 cid.Cid, payload []byte) ([]byte, error) {
	msg := Message{
		Protocol: cidV1.Bytes(),
		Payload:  payload,
	}
	return em.Marshal(msg)
}

func (m Message) MarshalCBOR() ([]byte, error) {
	tag := cbor.Tag{
		Number:  gridTagNum,
		Content: []interface{}{m.Protocol, m.Payload},
	}
	return em.Marshal(tag)
}

func (m *Message) UnmarshalCBOR(data []byte) error {
	var tag cbor.Tag
	if err := dm.Unmarshal(data, &tag); err != nil {
		return err
	}

	if tag.Number != gridTagNum {
		return fmt.Errorf("invalid grid tag number: %d", tag.Number)
	}

	parts, ok := tag.Content.([]interface{})
	if !ok || len(parts) != 2 {
		return fmt.Errorf("invalid content format, expected 2-element array")
	}

	// Decode protocol CID
	switch v := parts[0].(type) {
	case []byte:
		m.Protocol = v
	case nil:
		m.Protocol = nil
	default:
		return fmt.Errorf("protocol field has unexpected type: %T", parts[0])
	}

	// Decode payload
	switch v := parts[1].(type) {
	case []byte:
		m.Payload = v
	case nil:
		m.Payload = nil
	default:
		return fmt.Errorf("payload field has unexpected type: %T", parts[1])
	}

	return nil
}
```
EOF_/home/stevegt/lab/grid-poc/x/wire/wire.go

File: /home/stevegt/lab/grid-poc/x/wire/wire_test.go
```go
package wire

import (
	"bytes"
	"testing"

	"github.com/fxamacker/cbor/v2"
	"github.com/ipfs/go-cid"
	"github.com/multiformats/go-multihash"
)

func TestNewMessageRoundTrip(t *testing.T) {
	// Create CIDv1 with raw codec
	mh, _ := multihash.Sum([]byte("test"), multihash.SHA2_256, -1)
	c := cid.NewCidV1(cid.Raw, mh)
	payload := []byte{0x01, 0x02, 0x03}

	// Create and encode message
	encoded, err := NewMessage(c, payload)
	if err != nil {
		t.Fatalf("NewMessage failed: %v", err)
	}

	// Verify CBOR structure
	expectedPrefix := []byte{
		0xDA,             // Tag(4 bytes)
		0x67, 0x72, 0x69, 0x64, // Tag number 0x67726964 ('grid')
		0x82, // Array(2)
	}
	if !bytes.HasPrefix(encoded, expectedPrefix) {
		t.Errorf("Invalid CBOR structure\nGot:  %x\nWant prefix: %x", encoded, expectedPrefix)
	}

	// Decode message
	var decoded Message
	if err := cbor.Unmarshal(encoded, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Verify CID roundtrip
	decodedCID, err := cid.Cast(decoded.Protocol)
	if err != nil {
		t.Fatalf("CID cast failed: %v", err)
	}
	if !decodedCID.Equals(c) {
		t.Errorf("CID mismatch\nGot:  %s\nWant: %s", decodedCID, c)
	}

	// Verify payload
	if !bytes.Equal(decoded.Payload, payload) {
		t.Errorf("Payload mismatch\nGot:  %x\nWant: %x", decoded.Payload, payload)
	}
}

func TestEdgeCases(t *testing.T) {
	t.Run("empty payload", func(t *testing.T) {
		c, _ := cid.Decode("bafkreihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku")
		encoded, err := NewMessage(c, []byte{})
		if err != nil {
			t.Fatal(err)
		}

		var decoded Message
		if err := cbor.Unmarshal(encoded, &decoded); err != nil {
			t.Fatal(err)
		}

		if len(decoded.Payload) != 0 {
			t.Errorf("Expected empty payload, got %x", decoded.Payload)
		}
	})

	t.Run("nil payload", func(t *testing.T) {
		c, _ := cid.Decode("bafkreihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku")
		encoded, err := NewMessage(c, nil)
		if err != nil {
			t.Fatal(err)
		}

		var decoded Message
		if err := cbor.Unmarshal(encoded, &decoded); err != nil {
			t.Fatal(err)
		}

		if decoded.Payload != nil {
			t.Errorf("Expected nil payload, got %x", decoded.Payload)
		}
	})
}

func TestInvalidMessages(t *testing.T) {
	t.Run("invalid tag number", func(t *testing.T) {
		data := []byte{
			0xDA, // Tag(4 bytes)
			0x00, 0x00, 0x00, 0x00, // Invalid tag number
			0x82, // Array(2)
			0x40, // Empty bytes
			0x40, // Empty bytes
		}
		var m Message
		err := cbor.Unmarshal(data, &m)
		if err == nil {
			t.Error("Expected error for invalid tag number")
		}
	})

	t.Run("insufficient array elements", func(t *testing.T) {
		data := []byte{
			0xDA, 0x67, 0x72, 0x69, 0x64, // Valid grid tag
			0x81, // Array(1) instead of 2
			0x40, // Empty bytes
		}
		var m Message
		err := cbor.Unmarshal(data, &m)
		if err == nil {
			t.Error("Expected error for insufficient array elements")
		}
	})

	t.Run("non-array content", func(t *testing.T) {
		data := []byte{
			0xDA, 0x67, 0x72, 0x69, 0x64, // Valid grid tag
			0xA0, // Empty map instead of array
		}
		var m Message
		err := cbor.Unmarshal(data, &m)
		if err == nil {
			t.Error("Expected error for non-array content")
		}
	})
}
```
EOF_/home/stevegt/lab/grid-poc/x/wire/wire_test.go

<references>
[1] https://github.com/fxamacker/cbor
[2] https://pkg.go.dev/github.com/fxamacker/cbor/v2
[3] https://go.libhunt.com/cbor-alternatives
[4] https://docs.losant.com/workflows/logic/cbor-encode/
[5] https://www.rockwellautomation.com/en-nz/docs/factorytalk-design-studio/current/contents-ditamap/instructions/instruction-set/ascii-conversion-instructions.html
[6] https://ipld.io/specs/codecs/dag-cbor/spec/
[7] https://github.com/fxamacker/cbor/blob/master/decode.go
[8] https://forum.golangbridge.org/t/cbor-library-in-go-small-fast-reliable-no-crashes-on-malicious-data-api-is-encoding-json-toarray-and-keyasint-struct-tags-fxamacker-cbor-v1-3/15558
</references>
