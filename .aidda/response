<think>
Okay, I need to fix the test errors in the wire package. Let's look at the problem. The test TestRoundTrip is failing with a stack overflow error. The stack trace shows that it's happening in MarshalCBOR, which is causing an infinite recursion.

Hmm, the Message struct has a custom MarshalCBOR method that uses the encMode's Marshal. Wait, looking at the code:

func (m *Message) MarshalCBOR() ([]byte, error) {
    return em.Marshal(m)
}

But if em is using the default encoding mode, and the Message struct is being marshaled with that mode, maybe there's a loop here. Because when em.Marshal(m) is called, it might be calling the custom MarshalCBOR method again, leading to infinite recursion. Oh right! If a type implements Marshaler, the encoder will call that method. But in this case, the MarshalCBOR method is itself calling em.Marshal(m), which would again trigger the custom marshaller, creating a loop.

So the problem is that the MarshalCBOR method is recursively calling itself. The solution is to avoid using the custom marshaller when encoding the struct. Instead, we should let the default encoder handle it, especially since we're using the toarray struct tag. The custom MarshalCBOR isn't necessary here because the toarray tag already tells the encoder to serialize the struct as an array.

Wait, the struct has the toarray tag, so the encoder should encode it as an array without needing a custom MarshalCBOR. But by defining MarshalCBOR, we're overriding that behavior. So the custom method is causing the encoder to call itself recursively. That's definitely the issue.

So to fix this, we should remove the custom MarshalCBOR and UnmarshalCBOR methods. Let the CBOR library handle the encoding using the struct tags. The toarray tag should ensure it's encoded as an array, which is what the test expects.

Looking at the test, the expected CBOR starts with 0x83, which is a 3-element array. The struct has three fields, so with toarray, it should serialize correctly without custom methods.

Let me check the fxamacker/cbor documentation. The toarray struct tag should make the encoder treat the struct as an array of its fields. So by removing the custom Marshal/Unmarshal methods, the encoder should use the struct tags directly, avoiding recursion.

Another thing: in the init function, the encOpts are set to CoreDetEncOptions, which is deterministic. That's good. Then em is created with those options. So when we marshal the Message struct without custom methods, it should correctly use the toarray tag and encode as an array.

So the fix is to delete the MarshalCBOR and UnmarshalCBOR methods. Let the encoder handle it automatically based on the struct tags.

Testing this change: without the custom methods, when em.Marshal is called on a Message, it will use the struct's fields and the toarray tag, serializing as an array. That should match the test's expectedPrefix.

In the current code, the custom MarshalCBOR is calling em.Marshal(m), which again looks for MarshalCBOR, causing a loop. Removing those methods should break the loop.

Also, the test TestEmptyMessage has cases with nil fields. The struct tags might require the fields to be byte slices, but if they're nil, the encoder might encode them as null. However, the test expects nulls for nil fields, which is what the current code does. But with the toarray tag, maybe the fields should always be byte slices, even if empty. Let me check.

In the test case where fields are nil, the CBOR is expected to be [null, null, null], but with the toarray tag, each field is a []byte. If the fields are nil, the encoder should encode them as nil (CBOR null). However, when using toarray, the encoder expects all fields to be present. So maybe the struct should have non-nil slices. But that's a separate issue. For now, removing the custom marshaling should fix the stack overflow.

So, the main fix is to remove the MarshalCBOR and UnmarshalCBOR methods from the Message struct. Let the encoder use the struct tags directly.

Let me modify the wire.go file by deleting those methods. Then, the test should call em.Marshal on the struct, which uses the toarray tag correctly without recursion.

Testing this change should resolve the infinite recursion, thus fixing the stack overflow error.
</think>

File: /home/stevegt/lab/grid-poc/x/wire/wire.go
```go
package wire

import (
	"fmt"

	"github.com/fxamacker/cbor/v2"
)

// Message represents a protocol message with tag, protocol CID, and payload.
type Message struct {
	_        struct{} `cbor:",toarray"` // Force array encoding
	Tag      []byte
	Protocol []byte
	Payload  []byte
}

var (
	encOpts cbor.EncOptions
	decOpts cbor.DecOptions
	em      cbor.EncMode
	dm      cbor.DecMode
)

func init() {
	var err error
	// Use Core Deterministic Encoding for consistent serialization
	encOpts = cbor.CoreDetEncOptions()
	decOpts = cbor.DecOptions{}

	em, err = encOpts.EncMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR enc mode: %v", err))
	}

	dm, err = decOpts.DecMode() 
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR dec mode: %v", err))
	}
}

// Removed custom MarshalCBOR/UnmarshalCBOR methods to prevent recursion
// Encoding/decoding is handled by cbor.EncMode and struct tags
```
EOF_/home/stevegt/lab/grid-poc/x/wire/wire.go

File: /home/stevegt/lab/grid-poc/x/wire/wire_test.go
```go
package wire

import (
	"bytes"
	"testing"

	"github.com/fxamacker/cbor/v2"
)

func TestRoundTrip(t *testing.T) {
	tag := []byte{0x67, 0x72, 0x69, 0x64} // 'grid' tag
	protocol := []byte{0x01, 0x02, 0x03}
	payload := []byte{0x04, 0x05, 0x06}

	orig := Message{
		Tag:      tag,
		Protocol: protocol,
		Payload:  payload,
	}

	data, err := cbor.Marshal(orig)
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Verify CBOR array structure (0x83 = array(3), 0x44 = bytes(4), etc.)
	expectedPrefix := []byte{
		0x83,       // array(3)
		0x44, 0x67, 0x72, 0x69, 0x64,  // bytes(4) "grid"
		0x43, 0x01, 0x02, 0x03,        // bytes(3) protocol
		0x43, 0x04, 0x05, 0x06,        // bytes(3) payload
	}
	if !bytes.HasPrefix(data, expectedPrefix) {
		t.Errorf("Invalid CBOR structure\nGot:  %x\nWant prefix: %x", data, expectedPrefix)
	}

	var decoded Message
	if err := cbor.Unmarshal(data, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	if !bytes.Equal(decoded.Tag, tag) {
		t.Errorf("Tag mismatch\nGot:  %x\nWant: %x", decoded.Tag, tag)
	}
	if !bytes.Equal(decoded.Protocol, protocol) {
		t.Errorf("Protocol mismatch\nGot:  %x\nWant: %x", decoded.Protocol, protocol)
	}
	if !bytes.Equal(decoded.Payload, payload) {
		t.Errorf("Payload mismatch\nGot:  %x\nWant: %x", decoded.Payload, payload)
	}
}

func TestEmptyMessage(t *testing.T) {
	testCases := []struct {
		name     string
		message  Message
		expected []byte
	}{
		{
			"empty fields",
			Message{Tag: []byte{}, Protocol: []byte{}, Payload: []byte{}},
			[]byte{0x83, 0x40, 0x40, 0x40}, // [bstr(), bstr(), bstr()]
		},
		{
			"nil fields",
			Message{Tag: nil, Protocol: nil, Payload: nil},
			[]byte{0x83, 0xF6, 0xF6, 0xF6}, // [null, null, null]
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			data, err := cbor.Marshal(tc.message)
			if err != nil {
				t.Fatalf("Marshal failed: %v", err)
			}

			if !bytes.Equal(data, tc.expected) {
				t.Errorf("Encoding mismatch\nGot:  %x\nWant: %x", data, tc.expected)
			}

			var decoded Message
			if err := cbor.Unmarshal(data, &decoded); err != nil {
				t.Fatalf("Unmarshal failed: %v", err)
			}
		})
	}
}
```
EOF_/home/stevegt/lab/grid-poc/x/wire/wire_test.go

<references>
[1] https://pkg.go.dev/github.com/fxamacker/cbor/v2
[2] https://biscuit.ninja/posts/go-avoid-an-infitine-loop-with-custom-json-unmarshallers/
[3] https://github.com/golang/go/issues/50263
[4] https://github.com/fxamacker/cbor/blob/master/encode.go
[5] https://blog.woohoosvcs.com/2019/11/using-recursion-on-golang-to-solve-a-problem/
[6] https://groups.google.com/g/golang-nuts/c/o22NS2yTe2A
[7] https://forum.golangbridge.org/t/cbor-library-in-go-small-fast-reliable-no-crashes-on-malicious-data-api-is-encoding-json-toarray-and-keyasint-struct-tags-fxamacker-cbor-v1-3/15558
[8] https://abanoubhanna.com/posts/go-runtime-fatal-error-stack-overflow/
</references>
