File: /home/stevegt/lab/grid-poc/x/dispatcher/dispatcher.go
```go
package main

// Market interface represents a trading market with capabilities to fetch quotes and execute orders.
// It uses raw []byte for symbols and denominations which may be beneficial for low-level manipulations.
type Market interface {
	Quote(symbol, denomination []byte) (price float64, err error)
	Order(symbol, denomination []byte, amount float64) (OrderId []byte, err error)
}

// ---------------------------------------------------------------------------
// Discussion: Pros and Cons of AgentByte vs AgentMsg
//
// Considering that agents may be local or remote (including across the internet), written
// in any language, and operating with different trust levels, platforms, and hardware architectures,
// we need to carefully weigh the trade-offs between AgentByte and AgentMsg.
//
// AgentByte Interface:
//   Pros:
//     - Simplicity: Uses raw byte slices, offering great flexibility as no structured format is enforced.
//       This is beneficial when agents are written in different languages or must support dynamic message formats.
//     - Platform Agnostic: Byte slices are a universal data representation, easing interoperability
//       among agents running on different operating systems or hardware architectures.
//     - Lower Overhead (Pre-Processing): There is no need to serialize/deserialize complex structures before messaging,
//       which can be advantageous when latency is critical, provided that the message format is self-explanatory.
//   Cons:
//     - Parsing Overhead: Every agent must implement its own logic to interpret raw bytes, potentially leading to duplicated code and
//       inconsistencies in how data is parsed and validated.
//     - Ambiguity: The lack of a defined schema can result in ambiguous interpretations of the data.
//       This risk is especially increased when agents are written by different parties or when message integrity is crucial.
//     - Security Concerns: Without strict type guarantees, maliciously crafted messages can more easily exploit parsing vulnerabilities.
//
// AgentMsg Interface:
//   Pros:
//     - Efficiency in Processing: By transmitting messages that are already structured (pre-parsed), the receiver can avoid
//       the cost of runtime parsing and validation, resulting in faster message processing in trusted environments.
//     - Type Safety: The use of a structured message type (Msg) allows for compile-time checks where possible,
//       reducing the risk of runtime errors due to misinterpreted data.
//     - Clear Contract: A well-defined message format establishes a strict contract between agents, which is crucial in multi-language,
//       cross-platform environments where consistency is key.
//   Cons:
//     - Complexity: Pre-parsing messages require that senders reliably validate and structure the message content before transmission,
//       which increases system complexity.
//     - Reduced Flexibility: The enforced structure may limit the ability to quickly adapt the message format to new requirements,
//       particularly in heterogeneous environments where different agents might expect different data schemas.
//     - Trust Dependency: It assumes that the sender is fully trusted to generate correctly structured messages,
//       which might be problematic in scenarios where agents are built by different, potentially untrusted entities.
// ---------------------------------------------------------------------------

// AgentByte interface represents an event-based model where the message content is handled as raw bytes.
// This offers flexibility and universal compatibility but comes with the challenges of ambiguity, security, and duplicated parsing logic.
type AgentByte interface {
	Subscribe(prefix []byte) (subId []byte, msgbuf chan []byte, err error)
	Unsubscribe(subId []byte) (err error)
}

// Msg type is intended to represent a structured message, such as a COSE-signed CWT.
// This structure is a placeholder and should be expanded to include actual message fields and validations.
type Msg struct {
	// Msg is a COSE-signed CWT
	// XXX this is a placeholder
}

// AgentMsg interface uses a pre-parsed message type (Msg) for subscriptions.
// It enables efficient, type-safe communications at the expense of greater initial complexity and stricter contract enforcement.
type AgentMsg interface {
	Subscribe(prefix []Msg) (subId []byte, msgbuf chan Msg, err error)
	Unsubscribe(subId []byte) (err error)
}
```
EOF_/home/stevegt/lab/grid-poc/x/dispatcher/dispatcher.go