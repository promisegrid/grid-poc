File: /home/stevegt/lab/grid-poc/x/sim2/sim2.go
```go
package main

import (
	"fmt"
	"strings"
)

var simulateArbitrage = true
var tradeExecuted bool = false

// allAgents holds the list of all agents in the simulation for global
// lookup during settlement.
var allAgents []*Agent

// Message represents a bid or confirm message in the simulation.
// Every message must be either a BID or a CONFIRM and include a personal
// currency symbol and an amount. OrigBid carries the bid amount received
// from the upstream agent and is used by intermediaries when generating
// confirm messages.
type Message struct {
	Type    string   // "BID" or "CONFIRM"
	Amount  float64  // bid or confirm amount
	Symbol  string   // personal currency symbol (e.g. "ALICE")
	From    string   // sender agent ID
	History []string // list of agent IDs that have handled the message
	OrigBid float64  // original bid amount received from upstream (if any)
}

// Agent represents a simulation participant.
type Agent struct {
	ID          string
	Currency    string  // personal currency (e.g. "ALICE")
	Balance     float64
	Peers       []*Agent
	IsSeller    bool // Only Dave is the seller.
	IsBuyer     bool // Only Alice is the buyer.
	NextHop     *Agent
	PrevHop     *Agent
	upstreamBid float64 // bid amount received from upstream
}

// SendBidMessage sends a BID message to the next agent in the chain.
func (a *Agent) SendBidMessage(msg Message) {
	if a.NextHop == nil {
		return
	}
	// Append own ID to history.
	msg.History = append(msg.History, a.ID)
	fmt.Printf("%s sends %s message (%.2f %s) to %s\n",
		a.ID, msg.Type, msg.Amount, msg.Symbol, a.NextHop.ID)
	a.NextHop.ReceiveMessage(msg, a)
}

// SendConfirmMessage sends a CONFIRM message to the previous agent in the
// chain; if there is no previous agent (i.e. the buyer), it processes the
// final confirmation.
func (a *Agent) SendConfirmMessage(msg Message) {
	if a.PrevHop == nil {
		a.ReceiveFinalConfirm(msg)
		return
	}
	// Append own ID to history.
	msg.History = append(msg.History, a.ID)
	fmt.Printf("%s sends %s message (%.2f %s) to %s\n",
		a.ID, msg.Type, msg.Amount, msg.Symbol, a.PrevHop.ID)
	a.PrevHop.ReceiveMessage(msg, a)
}

// ReceiveMessage processes an incoming message based on its type and the role
// of the agent. For BID messages, intermediaries arbitrage by subtracting 1
// from the incoming bid and storing the upstream bid for later use in CONFIRM.
// The seller responds to a BID with a CONFIRM using the exact bid amount.
// CONFIRM messages are forwarded backward along the chain with intermediaries
// replacing the bid amount with the upstream bid value.
func (a *Agent) ReceiveMessage(msg Message, sender *Agent) {
	// Prevent processing the same message more than once.
	if contains(msg.History, a.ID) {
		return
	}
	if msg.Type == "BID" {
		// For a BID message, if this agent is the seller, respond with CONFIRM.
		if a.IsSeller {
			// Seller uses the bid's amount (using the bid currency).
			confirmMsg := Message{
				Type:    "CONFIRM",
				Amount:  msg.Amount,
				Symbol:  msg.Symbol, // Use the bid's currency symbol.
				From:    a.ID,
				History: []string{a.ID},
			}
			fmt.Printf("%s received BID from %s, responds with CONFIRM (%.2f%s)\n",
				a.ID, sender.ID, confirmMsg.Amount, confirmMsg.Symbol)
			a.SendConfirmMessage(confirmMsg)
			return
		} else if !a.IsBuyer && simulateArbitrage {
			// Intermediate agent: store the upstream bid amount.
			a.upstreamBid = msg.Amount
			// Arbitrage: subtract 1 from the incoming bid.
			newBidAmount := msg.Amount - 1
			newBid := Message{
				Type:    "BID",
				Amount:  newBidAmount,
				Symbol:  a.Currency, // Use own currency for new BID.
				From:    a.ID,
				History: append([]string{}, msg.History...),
				OrigBid: msg.Amount, // Preserve the upstream bid.
			}
			fmt.Printf("%s (intermediary) received BID from %s, arbitraging to "+
				"new BID: %.2f%s\n", a.ID, sender.ID, newBid.Amount,
				newBid.Symbol)
			a.SendBidMessage(newBid)
			return
		}
		// If buyer or not eligible, simply forward the BID.
		fmt.Printf("%s received BID message from %s, forwarding...\n",
			a.ID, sender.ID)
		a.SendBidMessage(msg)
	} else if msg.Type == "CONFIRM" {
		if a.IsBuyer {
			// Buyer processes the final CONFIRM and settles the trade.
			if !tradeExecuted {
				// For this simulation, the buyer pays the confirm amount.
				fmt.Printf("%s (buyer) received CONFIRM from %s with price "+
					"%.2f%s, trade executed!\n", a.ID, sender.ID, msg.Amount,
					msg.Symbol)
				a.Balance -= msg.Amount
				// Settle trade with the seller.
				seller := findSeller(allAgents)
				if seller != nil {
					seller.Balance += msg.Amount
					fmt.Printf("Trade settled: %s pays %.2f%s to %s\n",
						a.ID, msg.Amount, msg.Symbol, seller.ID)
				} else {
					fmt.Printf("Seller not found in the simulation.\n")
				}
				tradeExecuted = true
			}
			return
		}
		// Intermediate agent: generate a new CONFIRM using the stored upstream
		// bid amount and the currency of the previous hop.
		newConfirm := Message{
			Type:   "CONFIRM",
			Amount: a.upstreamBid,
			// The confirm uses the upstream agent's currency.
			Symbol: a.PrevHop.Currency,
			From:   msg.From,
			// Start history with current agent for the backward journey.
			History: []string{a.ID},
		}
		fmt.Printf("%s processed CONFIRM message from %s, generating new "+
			"CONFIRM with price %.2f%s\n", a.ID, sender.ID, newConfirm.Amount,
			newConfirm.Symbol)
		a.SendConfirmMessage(newConfirm)
	} else {
		fmt.Printf("%s received unknown message type %s from %s\n",
			a.ID, msg.Type, sender.ID)
	}
}

// ReceiveFinalConfirm is called by the buyer when no previous agent exists.
// It finalizes the trade; in this simulation, the buyer processes the final
// confirmation.
func (a *Agent) ReceiveFinalConfirm(msg Message) {
	if !tradeExecuted {
		fmt.Printf("%s (buyer) received final CONFIRM with price %.2f%s, "+
			"trade executed!\n", a.ID, msg.Amount, msg.Symbol)
		a.Balance -= msg.Amount
		seller := findSeller(allAgents)
		if seller != nil {
			seller.Balance += msg.Amount
			fmt.Printf("Trade settled: %s pays %.2f%s to %s\n",
				a.ID, msg.Amount, msg.Symbol, seller.ID)
		} else {
			fmt.Printf("Seller not found in the simulation.\n")
		}
		tradeExecuted = true
	}
}

// contains returns true if s is in the slice.
func contains(slice []string, s string) bool {
	for _, v := range slice {
		if v == s {
			return true
		}
	}
	return false
}

// findSeller returns the first agent in agents who is marked as the seller.
func findSeller(agents []*Agent) *Agent {
	for _, agent := range agents {
		if agent.IsSeller {
			return agent
		}
	}
	return nil
}

// RunSimulation initializes the four agents and simulates a double-auction
// message pass using personal currencies across a multi-hop network.
// Scenario: Alice, Bob, and Carol form a BID chain and Bob, Carol, and Dave form
// the corresponding chain for forwarding. Alice and Dave cannot communicate
// directly.
func RunSimulation() (alice, bob, carol, dave *Agent) {
	tradeExecuted = false
	alice = &Agent{ID: "Alice", Balance: 100.0, IsBuyer: true,
		Currency: "ALICE"}
	bob = &Agent{ID: "Bob", Balance: 100.0, Currency: "BOB"}
	carol = &Agent{ID: "Carol", Balance: 100.0, Currency: "CAROL"}
	dave = &Agent{ID: "Dave", Balance: 100.0, IsSeller: true,
		Currency: "DAVE"}

	// Set up peer connections (full mesh for potential lookups).
	alice.Peers = []*Agent{bob, carol}
	bob.Peers = []*Agent{alice, carol, dave}
	carol.Peers = []*Agent{alice, bob, dave}
	dave.Peers = []*Agent{bob, carol}

	// Define the chain order using NextHop and PrevHop.
	// Chain: Alice -> Bob -> Carol -> Dave.
	alice.NextHop = bob
	alice.PrevHop = nil

	bob.NextHop = carol
	bob.PrevHop = alice

	carol.NextHop = dave
	carol.PrevHop = bob

	dave.NextHop = nil
	dave.PrevHop = carol

	// Initialize global agent list.
	allAgents = []*Agent{alice, bob, carol, dave}

	// Alice initiates the auction by sending a BID message with her currency.
	bidMsg := Message{
		Type:    "BID",
		Amount:  50.0,
		Symbol:  alice.Currency,
		From:    alice.ID,
		History: []string{},
	}
	alice.SendBidMessage(bidMsg)
	return alice, bob, carol, dave
}

// simulateAuction runs the simulation and prints final agent balances.
func simulateAuction() {
	alice, bob, carol, dave := RunSimulation()
	fmt.Println("\nFinal Balances:")
	// Display each agent's balance along with their personal currency.
	fmt.Printf("Alice: %.2f %s\n", alice.Balance, alice.Currency)
	fmt.Printf("Bob: %.2f %s\n", bob.Balance, bob.Currency)
	fmt.Printf("Carol: %.2f %s\n", carol.Balance, carol.Currency)
	fmt.Printf("Dave: %.2f %s\n", dave.Balance, dave.Currency)
}

func main() {
	fmt.Println(strings.Repeat("=", 70))
	fmt.Println("Starting Auction Simulation")
	fmt.Println(strings.Repeat("=", 70))
	simulateAuction()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2.go

File: /home/stevegt/lab/grid-poc/x/sim2/sim2_test.go
```go
package main

import "testing"

// TestSimulationTrade verifies that a trade occurs during the simulation.
// With arbitrage enabled, intermediaries modify the BID such that a BID of 50
// becomes 49 before reaching the seller, and then 48 for the last hop.
// The seller responds with a CONFIRM using the received bid amount (48).
// Intermediaries then propagate confirmation using the original upstream bid:
// Carol sends CONFIRM with 49 (from Bob's original bid) to Bob, and Bob sends
// CONFIRM with 50 (from Alice's bid) to Alice. Therefore, we expect the buyer
// (Alice) to pay 50 and the seller (Dave) to receive that amount.
func TestSimulationTrade(t *testing.T) {
	alice, _, _, dave := RunSimulation()
	// With arbitrage, the final trade executes at a CONFIRM price of 50.
	expectedBuyerBalance := 100.0 - 50.0
	expectedSellerBalance := 100.0 + 50.0

	if alice.Balance != expectedBuyerBalance {
		t.Errorf("Expected Alice balance to be %.2f, got %.2f",
			expectedBuyerBalance, alice.Balance)
	}
	if dave.Balance != expectedSellerBalance {
		t.Errorf("Expected Dave balance to be %.2f, got %.2f",
			expectedSellerBalance, dave.Balance)
	}
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2_test.go

File: /home/stevegt/lab/grid-poc/x/sim2/design.md
```markdown
# Sim2 Design Document: Double-Auction Routing Simulation

This document describes the design and protocol for Sim2, a
simulation of a decentralized, double-auction based routing mechanism
for PromiseGrid. The goal is to fairly allocate resources and prevent
spam using a double-auction market. In this protocol, agents exchange
bids and asks using personal currencies, and every message carries a
currency symbol and amount.

## Protocol Overview

Sim2 employs a peer-to-peer message passing system in which all
communication is local. Agents send messages directly to their
neighbors as defined by their peer connections. In our simulation the
agents are Alice, Bob, Carol, and Dave, with the following network:
- Alice, Bob, and Carol are direct peers.
- Bob, Carol, and Dave are direct peers.
- Alice and Dave cannot communicate directly but route messages via
  intermediate peers.

Each message represents either a bid or an ask. The buyer (Alice)
initiates a BID, and the seller (Dave) responds with a CONFIRM. 

## Personal Currencies and Economic Incentives

Every agent has its own personal currency: "ALICE", "BOB", "CAROL", and
"DAVE". These currencies are used in bid and ask messages. An agentâ€™s
balance is adjusted when a trade is executed. 

Agents trade each others' currencies as a means of valuing relative
trustworthiness; for example, if Alice trusts Bob, she may buy some of
Bob's currency to use in future transactions.  Unrustworthy or abusive
behavior would cause other agents to sell that agent's currency,
reducing its value.

Intermediate agents don't forward messages; they instead use
arbitrage. They create their own bid or ask orders based on received
messages, effectively acting as market makers or arbitrageurs. This
allows them to profit from the difference between the bid and ask
prices, incentivizing their participation in the network.

Here's an example of how this works in practice:
- Alice sends BID message (50.00 ALICE) to Bob
- Bob (intermediary) received BID from Alice, arbitraging to new BID: 49.00
  BOB
- Bob sends BID message (49.00 BOB) to Carol
- Carol (intermediary) received BID from Bob, arbitraging to new BID: 48.00
  CAROL
- Carol sends BID message (48.00 CAROL) to Dave
- Dave received BID from Carol, responds with CONFIRM (48.00 CAROL)
- Carol received CONFIRM from Dave, which triggers her sending a CONFIRM
  to Bob (49.00 BOB)
- Bob receives CONFIRM from Carol and sends a final CONFIRM to Alice (50.00
  ALICE)

## Simulation Details

The simulation is implemented in Go and encapsulated in a single file,
sim2.go, with testing in sim2_test.go. Key design aspects include:

- **Peer-to-Peer Exchange:** There is no central authority. Instead,
  messages propagate through a network of direct connections.

## Implementation Considerations

The design emphasizes minimalism and dependency-free code that can be
deployed even on resource-constrained devices such as IoT platforms.
The simulation uses in-memory data structures and simple string slicing
for routing. Message histories prevent loops, and the forwarding
mechanism ensures that each agent processes a message only once.

## Conclusion

Sim2 demonstrates a market-based approach to decentralized routing using
a double-auction mechanism. It shows how economic principles like
price discovery and auction matching can be applied to networking to
achieve fair resource allocation and spam prevention. This design is
intended to serve as a proof-of-concept for integrating economic models
into multi-hop, peer-to-peer communication protocols in PromiseGrid.
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/design.md