File: /home/stevegt/lab/grid-poc/x/sim2/sim2.go
```go
package main

import (
	"fmt"
	"strings"
)

var simulateArbitrage = true
var tradeExecuted bool = false

// allAgents holds the list of all agents in the simulation for global
// lookup during settlement.
var allAgents []*Agent

// Message represents a bid, confirm, or ask message in the simulation.
// Every message must be either a BID or a CONFIRM and include a personal
// currency symbol and an amount.
type Message struct {
	Type    string   // "BID" or "CONFIRM"
	Amount  float64  // bid or confirm amount
	Symbol  string   // personal currency symbol (e.g. "ALICE")
	From    string   // sender agent ID
	History []string // list of agent IDs that have handled the message
}

// Agent represents a simulation participant.
type Agent struct {
	ID       string
	Currency string  // personal currency (e.g. "ALICE")
	Balance  float64
	Peers    []*Agent
	IsSeller bool // Only Dave is the seller.
	IsBuyer  bool // Only Alice is the buyer.
}

// SendMessage sends a message to all peers, skipping those already in the
// message history to avoid loops. If the message's symbol is empty, it uses
// the sender's personal currency.
func (a *Agent) SendMessage(msg Message) {
	if msg.Symbol == "" {
		msg.Symbol = a.Currency
	}
	// Append self to history.
	msg.History = append(msg.History, a.ID)
	for _, peer := range a.Peers {
		// Avoid sending to peers already in the history.
		if contains(msg.History, peer.ID) {
			continue
		}
		fmt.Printf("%s sends %s message (%.2f %s) to %s\n", a.ID, msg.Type,
			msg.Amount, msg.Symbol, peer.ID)
		peer.ReceiveMessage(msg, a)
	}
}

// ReceiveMessage processes an incoming message based on type and role.
// Sellers respond to BID messages by issuing a CONFIRM using the bid's
// currency and the computed price (bid amount minus 5).
// Buyers accept acceptable CONFIRM messages. Intermediate agents process
// CONFIRM messages by generating a new CONFIRM that preserves the original
// seller's identity so that final settlement occurs between buyer and seller.
func (a *Agent) ReceiveMessage(msg Message, sender *Agent) {
	if contains(msg.History, a.ID) {
		return
	}
	msg.History = append(msg.History, a.ID)
	if msg.Type == "BID" {
		if a.IsSeller {
			confirmPrice := msg.Amount - 5.0
			if confirmPrice < 0 {
				confirmPrice = 0
			}
			confirmMsg := Message{
				Type:    "CONFIRM",
				Amount:  confirmPrice,
				// Use the bid's currency for the confirm message.
				Symbol: msg.Symbol,
				From:   a.ID,
				// Start history with the seller's ID.
				History: []string{a.ID},
			}
			fmt.Printf("%s received BID from %s, responds with CONFIRM (%.2f%s)\n",
				a.ID, msg.From, confirmMsg.Amount, confirmMsg.Symbol)
			a.SendMessage(confirmMsg)
			return
		} else if !a.IsBuyer && simulateArbitrage {
			newBid := Message{
				Type:    "BID",
				Amount:  msg.Amount - 1,
				// Intermediary uses its own currency for its bid.
				Symbol:  a.Currency,
				From:    a.ID,
				History: append([]string{}, msg.History...),
			}
			fmt.Printf("%s (intermediary) received BID from %s, arbitraging to "+
				"new BID: %.2f%s\n", a.ID, msg.From, newBid.Amount,
				newBid.Symbol)
			a.SendMessage(newBid)
			return
		}
		fmt.Printf("%s received BID message from %s, forwarding...\n",
			a.ID, sender.ID)
		a.SendMessage(msg)
	} else if msg.Type == "CONFIRM" {
		if a.IsBuyer {
			if !tradeExecuted && msg.Amount <= 50.0 {
				fmt.Printf("%s (buyer) received CONFIRM from %s with price "+
					"%.2f%s, trade executed!\n", a.ID, msg.From, msg.Amount,
					msg.Symbol)
				a.Balance -= msg.Amount
				// Settle trade using original seller from msg.History.
				if len(msg.History) > 0 {
					seller := findAgentByID(allAgents, msg.History[0])
					if seller != nil {
						seller.Balance += msg.Amount
						fmt.Printf("Trade settled: %s pays %.2f%s to %s\n",
							a.ID, msg.Amount, msg.Symbol, seller.ID)
					} else {
						fmt.Printf("Seller %s not found in the simulation.\n",
							msg.History[0])
					}
				} else {
					fmt.Printf("No seller information in CONFIRM message.\n")
				}
				tradeExecuted = true
			} else if !tradeExecuted && msg.Amount > 50.0 {
				fmt.Printf("%s (buyer) received high CONFIRM price %.2f%s from %s, "+
					"rejecting trade\n", a.ID, msg.Amount, msg.Symbol, msg.From)
			}
			return
		}
		// Intermediate agents process CONFIRM messages by generating a new
		// CONFIRM that preserves the original seller's identity.
		newConfirm := Message{
			Type:    "CONFIRM",
			Amount:  msg.Amount,
			// Retain the original bid currency.
			Symbol: msg.Symbol,
			// Preserve original seller ID from the message.
			From: msg.From,
			History: append(msg.History, a.ID),
		}
		fmt.Printf("%s processed CONFIRM message from %s, generating new "+
			"CONFIRM with price %.2f%s\n", a.ID, sender.ID, newConfirm.Amount,
			newConfirm.Symbol)
		a.SendMessage(newConfirm)
	} else {
		fmt.Printf("%s received unknown message type %s from %s\n",
			a.ID, msg.Type, sender.ID)
	}
}

// contains returns true if s is in the slice.
func contains(slice []string, s string) bool {
	for _, v := range slice {
		if v == s {
			return true
		}
	}
	return false
}

// findAgentByID returns the first agent in agents with a matching ID.
func findAgentByID(agents []*Agent, id string) *Agent {
	for _, agent := range agents {
		if agent.ID == id {
			return agent
		}
	}
	return nil
}

// RunSimulation initializes the four agents and simulates a double-auction
// message pass using personal currencies across a multi-hop network.
// Scenario: Alice, Bob, and Carol are peers; Bob, Carol, and Dave are peers.
// Alice and Dave cannot communicate directly.
func RunSimulation() (alice, bob, carol, dave *Agent) {
	tradeExecuted = false
	alice = &Agent{ID: "Alice", Balance: 100.0, IsBuyer: true,
		Currency: "ALICE"}
	bob = &Agent{ID: "Bob", Balance: 100.0, Currency: "BOB"}
	carol = &Agent{ID: "Carol", Balance: 100.0, Currency: "CAROL"}
	dave = &Agent{ID: "Dave", Balance: 100.0, IsSeller: true,
		Currency: "DAVE"}

	// Set up peer connections:
	// Alice, Bob, and Carol are mutually connected.
	// Bob, Carol, and Dave are mutually connected.
	alice.Peers = []*Agent{bob, carol}
	bob.Peers = []*Agent{alice, carol, dave}
	carol.Peers = []*Agent{alice, bob, dave}
	dave.Peers = []*Agent{bob, carol}

	// Initialize global agent list.
	allAgents = []*Agent{alice, bob, carol, dave}

	// Alice initiates the auction by sending a BID message with her currency.
	bidMsg := Message{
		Type:    "BID",
		Amount:  50.0,
		Symbol:  alice.Currency,
		From:    alice.ID,
		History: []string{},
	}
	alice.SendMessage(bidMsg)
	return alice, bob, carol, dave
}

// simulateAuction runs the simulation and prints final agent balances.
func simulateAuction() {
	alice, bob, carol, dave := RunSimulation()
	fmt.Println("\nFinal Balances:")
	// Display each agent's balance along with their personal currency.
	fmt.Printf("Alice: %.2f %s\n", alice.Balance, alice.Currency)
	fmt.Printf("Bob: %.2f %s\n", bob.Balance, bob.Currency)
	fmt.Printf("Carol: %.2f %s\n", carol.Balance, carol.Currency)
	fmt.Printf("Dave: %.2f %s\n", dave.Balance, dave.Currency)
}

func main() {
	fmt.Println(strings.Repeat("=", 70))
	fmt.Println("Starting Auction Simulation")
	fmt.Println(strings.Repeat("=", 70))
	simulateAuction()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2.go

File: /home/stevegt/lab/grid-poc/x/sim2/sim2_test.go
```go
package main

import "testing"

// TestSimulationTrade verifies that a trade occurs during the simulation.
// With arbitrage enabled, intermediaries modify the BID such that a BID of 50
// becomes 49 before reaching the seller. The seller then responds with a
// CONFIRM price of 44 (i.e. 49 - 5). Therefore, we expect the buyer (Alice) to
// pay 44 and the seller (Dave) to receive that amount.
func TestSimulationTrade(t *testing.T) {
	alice, _, _, dave := RunSimulation()
	// With arbitrage, the trade executes at a CONFIRM price of 44.
	expectedBuyerBalance := 100.0 - 44.0
	expectedSellerBalance := 100.0 + 44.0

	if alice.Balance != expectedBuyerBalance {
		t.Errorf("Expected Alice balance to be %.2f, got %.2f",
			expectedBuyerBalance, alice.Balance)
	}
	if dave.Balance != expectedSellerBalance {
		t.Errorf("Expected Dave balance to be %.2f, got %.2f",
			expectedSellerBalance, dave.Balance)
	}
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/sim2_test.go

File: /home/stevegt/lab/grid-poc/x/sim2/design.md
```markdown
# Sim2 Design Document: Double-Auction Routing Simulation

This document describes the design and protocol for Sim2, a
simulation of a decentralized, double-auction based routing mechanism
for PromiseGrid. The goal is to fairly allocate resources and prevent
spam using a double-auction market. In this protocol, agents exchange
bids and asks using personal currencies, and every message carries a
currency symbol and amount.

## Protocol Overview

Sim2 employs a peer-to-peer message passing system in which all
communication is local. Agents send messages directly to their
neighbors as defined by their peer connections. In our simulation the
agents are Alice, Bob, Carol, and Dave, with the following network:
- Alice, Bob, and Carol are direct peers.
- Bob, Carol, and Dave are direct peers.
- Alice and Dave cannot communicate directly but route messages via
  intermediate peers.

Each message represents either a bid or an ask. The buyer (Alice)
initiates a BID, and the seller (Dave) responds with an ASK. 

## Personal Currencies and Economic Incentives

Every agent has its own personal currency: "ALICE", "BOB", "CAROL", and
"DAVE". These currencies are used in bid and ask messages. An agentâ€™s
balance is adjusted when a trade is executed. 

Agents trade each others' currencies as a means of valuing relative
trustworthiness; for example, if Alice trusts Bob, she may buy some of
Bob's currency to use in future transactions.  Unrustworthy or abusive
behavior would cause other agents to sell that agent's currency,
reducing its value.

Intermediate agents don't forward messages; they instead use
arbitrage. They create their own mid or ask orders based on received
messages, effectively acting as market makers or arbitrageurs. This
allows them to profit from the difference between the bid and ask
prices, incentivizing their participation in the network.

Here's and example of how this works in practice:
- Alice, Bob, Carol, and Dave all start with zero balances in all
  currencies.
- Alice wants to pay 10 ALICE for the results of a function call that
  only Dave can perform. She sends a BID message to Bob, who is her
  direct peer.  The BID message contains the amount (10 ALICE), the
  currency symbol ("ALICE"), and the function call f(2, 3).
- Bob receives the BID and thinks that he might profit by acting as an
  intermediary.  He sends a new BID message to Carol, promising to pay
  her 9 BOB for the same function call f(2, 3). The BID message
  contains the amount (9 BOB), the currency symbol ("BOB"), and the
  function call f(2, 3).
- Carol receives Bob's BID and decides to act as an intermediary as
  well. She sends a new BID message to Dave, promising to pay him 8
  CAROL for the same function call f(2, 3). The BID message contains
  the amount (8 CAROL), the currency symbol ("CAROL"), and the
  function call f(2, 3).
- Dave receives Carol's BID and decides to accept it.  He performs the
  function call f(2, 3) and calculates the result, which is 5. He then
  sends a CONFIRM message back to Carol, including the result (5).
- Carol receives Dave's CONFIRM and sends a CONFIRM message back to
  Bob, including the result (5).
- Bob receives Carol's CONFIRM and sends a CONFIRM message back to
  Alice, including the result (5).
- Alice receives Bob's CONFIRM and now knows the result of the
  function call f(2, 3) is 5.
- Alice now owes 10 ALICE to Bob, who owes 9 BOB to Carol, who owes
  8 CAROL to Dave.  Each agent maintains double-entry accounting to
  track these debits and credits in the proper asset and liability
  accounts.

## Simulation Details

The simulation is implemented in Go and encapsulated in a single file,
sim2.go, with testing in sim2_test.go. Key design aspects include:

- **Peer-to-Peer Exchange:** There is no central authority. Instead,
  messages propagate through a network of direct connections.

## Implementation Considerations

The design emphasizes minimalism and dependency-free code that can be
deployed even on resource-constrained devices such as IoT platforms.
The simulation uses in-memory data structures and simple string slicing
for routing. Message histories prevent loops, and the forwarding
mechanism ensures that each agent processes a message only once.

## Conclusion

Sim2 demonstrates a market-based approach to decentralized routing using
a double-auction mechanism. It shows how economic principles like
price discovery and auction matching can be applied to networking to
achieve fair resource allocation and spam prevention. This design is
intended to serve as a proof-of-concept for integrating economic models
into multi-hop, peer-to-peer communication protocols in PromiseGrid.
```
EOF_/home/stevegt/lab/grid-poc/x/sim2/design.md