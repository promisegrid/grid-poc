File: /home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md
```markdown
# Worldline Completion Model in Messaging Systems

The worldline completion model offers an innovative approach to managing events in a messaging system. It emphasizes creating, editing, and verifying a complete history of events for any given conversation or entity via a Merkle DAG structure. This document reviews the pros and cons of this model, provides a design outline of a worldline data structure, presents concrete examples with agents like Alice and Bob, and discusses how operations (DAG edits, queries, and subscriptions) can be expressed as CWT claims. Finally, it reviews the document for any inconsistencies.

---

## Overview of the Worldline Completion Model

In this model, each message is not just an isolated signal but a DAG edit operation—a promise that, when applied, transforms the current state of a worldline (the ordered history of events). Key characteristics include:

- **Multiple Worldlines:**  
  Worldlines can branch and merge, meaning that multiple histories can evolve concurrently. A single event (or message) may appear in more than one worldline, providing perspectives from different agents or system states.

- **DAG-Based Organization:**  
  Instead of simple sequence numbers, events are arranged in a Merkle DAG. Here:
  - **Leaves (Events):** Contain the event data (such as a text message) and metadata (timestamp, agent identifier, and payload promises) but do not include a pointer to the previous event.
  - **Internal Nodes:** Maintain the hashes of their children in worldline order, ensuring integrity and verifiability.

- **Flexible Editing:**  
  The model supports inserting, deleting, and reordering events in the DAG via an integrated editing language. Notably, the same language is used for DAG edits, queries, and subscriptions. Each DAG edit message is a promise (often expressed as CWT claims) that a specific event exists at a point on a worldline.

- **Event Integrity and Agent Signatures:**  
  Each event is signed by the agent that created it, and timestamps are provided from that agent’s perspective, enabling robust tracking across divergent histories.

---

## Worldline Data Structure

A possible implementation of a worldline event in Go-style pseudocode might look like:

```go
type WorldlineEvent struct {
    Timestamp time.Time // Agent-specific timestamp.
    Agent     string    // Identifier for the creator, e.g., "Alice" or "Bob".
    // Payload contains a set of PT-style promises expressed as CWT claims.
    Payload   []byte    
}
```

**Merkle DAG Characteristics:**

- **Editable History:**  
  Editing the DAG is accomplished through messages that perform insert, delete, or reorder operations. The internal nodes update the order by storing the hashes of their children, thus ensuring that any edit operation preserves the integrity of the history.
  
- **No Previous Hash in Leaves:**  
  Each event (a leaf node) does not store the hash of the previous event. Instead, ordering and integrity are guaranteed by the internal nodes.
  
- **Unified Editing Language:**  
  The language used for editing the DAG is the same as that used for querying and subscribing to events. This simplifies the overall design and ensures consistency across operations.

---

## Example Scenarios

### 1. DAG Edit Message Example

An agent (e.g., Alice) sends a message that performs a DAG edit, such as inserting an event into the worldline. The message is a promise that the event now exists at a specific location in the DAG.

**Example JSON Representation:**

```json
{
  "op": "insert",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:05:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"promise": "Event 'Hello' inserted", "detail": "Initial greeting"}
    ]
  },
  "signature": "abc123signature"
}
```

This is a DAG edit message where Alice promises to insert a "Hello" event into the worldline identified by `worldline123`.

### 2. DAG Query Message Example

An agent (e.g., Bob) might query a worldline to retrieve all events after a certain point. The query message is also expressed with CWT claims:

**Example JSON Representation:**

```json
{
  "op": "query",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:10:00Z",
  "target": "worldline123",
  "criteria": {
    "since": "2023-10-01T10:00:00Z"
  },
  "claims": [
    {"promise": "Retrieve all events after specified timestamp"}
  ],
  "signature": "bobSignatureXYZ"
}
```

This query returns the subset of the DAG events that match the criteria.

### 3. DAG Subscription Message Example

An agent can subscribe to changes in a worldline (or a subset of it) using a subscription message. This enables real-time notifications as the DAG updates.

**Example JSON Representation:**

```json
{
  "op": "subscribe",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:15:00Z",
  "target": "worldline123",
  "criteria": {
    "filter": "insert"
  },
  "claims": [
    {"promise": "Subscribe to insertion events in the worldline"}
  ],
  "signature": "bobSubsSignature456"
}
```

This message expresses Bob’s intent to receive notifications whenever an insertion operation occurs on `worldline123`.

---

## Expressing Operations as CWT Claims

All the above messages (DAG edit, query, and subscription) can be expressed as CWT (CBOR Web Token) claims, which serve as signed "promises" in the system:

- **DAG Edit Message Claims:**  
  They promise a change in the worldline state (e.g., an inserted event exists at a specified location).
  
- **DAG Query Message Claims:**  
  They promise to retrieve events that satisfy certain conditions, effectively verifying the state of the DAG.
  
- **DAG Subscription Message Claims:**  
  They promise ongoing updates based on the criteria, enabling agents to maintain synchronization with the evolving worldline.

Each CWT claim is digitally signed by the agent, ensuring authenticity and non-repudiation.

---

## Consistency and Terminology Review

Throughout this document, the terms "message" and "event" are used. However, there is an inherent ambiguity since these terms are sometimes used interchangeably. For better clarity and consistency:

- **Recommendation:**  
  Use "event" to refer to the immutable record stored in the Merkle DAG. Use "message" to denote the DAG edit (or query/subscription) operation that proposes a change or requests data.
  
- **Identified Inconsistency:**  
  In practice and within various parts of this document, "message" is used to describe both the edit operation and the stored event. It is recommended to strictly reserve "event" for the immutable record and "message" for the operational promise (i.e., the DAG edit).

---

## Conclusion

The worldline completion model with a Merkle DAG structure provides a robust framework for managing historical data in messaging systems:
- It enables branchable and mergeable worldlines.
- It supports flexible editing operations (insert, delete, reorder) while ensuring data integrity.
- It allows agents like Alice and Bob to not only exchange messages but also reconstruct the true conversation history.
- Expressing DAG operations as CWT claims offers a secure method for validating these promises.

While the approach offers enhanced auditability and resilience, it also introduces added complexity and resource overhead. Careful design and clear distinction between "message" (the proposal or command) and "event" (the resultant immutable record) is essential to avoid confusion.
```
EOF_/home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md