The error

  package cbor-codec/codec is not in std

comes from the fact that in codec_test.go you are importing the package as "cbor-codec/codec" even though the tests are in the same package (and the import path “cbor-codec/codec” is not a valid module path). There are two common ways to fix this depending on your preferred project structure:

───────────────────────────── Option 1: Remove the Redundant Import ─────────────────────────────

Since the test file is located in the same directory and declares

  package codec

you don’t need to import the codec package again. Remove the following import line from codec_test.go:

  "cbor-codec/codec"

Then update all references in the test file that currently use the prefix “codec.” to simply refer directly to the functions/types (or if needed, use unqualified identifiers). For example, change:

  c := codec.NewCodec(config)

to

  c := NewCodec(config)

and so on for other functions like StringToNum, etc.

───────────────────────────── Option 2: Use the Correct Module Import Path ─────────────────────────────

If you intend to keep the tests in a different package or want to import the codec package externally, then ensure that your module’s go.mod file declares your module path (for example, something like “github.com/stevegt/grid-poc”) and update the import accordingly. For instance, if the codec package is located under

  github.com/stevegt/grid-poc/x/cbor-codec/codec

then update the import in codec_test.go to:

  import "github.com/stevegt/grid-poc/x/cbor-codec/codec"

and (if necessary) change the test package line at the top to a different package (e.g. “package codec_test”) so that it can import the codec package.

───────────────────────────── Example Fix (Option 1) ─────────────────────────────

Below is the revised codec_test.go where the duplicate import has been removed and the references adjusted (assuming you want the tests to remain in the same package):

-------------------------------------------------
File: /home/stevegt/lab/grid-poc/x/cbor-codec/codec_test.go
-------------------------------------------------
package codec

import (
	"encoding/hex"
	"testing"

	"github.com/fxamacker/cbor/v2"
	. "github.com/stevegt/goadapt"
	"github.com/stretchr/testify/assert"
)

// PrintDiag prints a human-readable diagnostic string for the given CBOR buffer.
func PrintDiag(buf []byte) {
	// Diagnose the CBOR data
	dm, err := cbor.DiagOptions{
		ByteStringText:         true,
		ByteStringEmbeddedCBOR: true,
	}.DiagMode()
	Ck(err)
	diagnosis, err := dm.Diagnose(buf)
	Ck(err)
	Pl(diagnosis)
}

// Test payload types
type GridPayload struct {
	ID        []byte
	Timestamp uint64
}

type ImagePayload struct {
	Width  uint
	Height uint
	Format string
}

type SensorData struct {
	SensorID  string
	Temp      float64
	Precision uint8
}

const (
	GridTag   = 1735551332
	ImageTag  = 1735551333
	SensorTag = 1735551334
)

func setupCodec(t *testing.T) *Codec {
	config := CodecConfig{
		EncOptions: cbor.CoreDetEncOptions(),
		DecOptions: cbor.DecOptions{},
	}

	c, err := NewCodec(config)
	assert.NoError(t, err)

	assert.NoError(t, c.RegisterTagNumber(GridTag, GridPayload{}))
	assert.NoError(t, c.RegisterTagNumber(ImageTag, ImagePayload{}))
	assert.NoError(t, c.RegisterTagNumber(SensorTag, SensorData{}))

	return c
}

func TestEncode(t *testing.T) {
	c := setupCodec(t)

	tests := []struct {
		name    string
		payload interface{}
		wantHex string
	}{
		{
			name: "GridPayload",
			payload: GridPayload{
				ID:        []byte{0x01, 0x02},
				Timestamp: 1614124800,
			},
			wantHex: "da67726964a26249444201026954696d657374616d701a60359700",
		},
		{
			name: "ImagePayload",
			payload: ImagePayload{
				Width:  800,
				Height: 600,
				Format: "JPEG",
			},
			wantHex: "da67726965a365576964746819032066466f726d6174644a50454766486569676874190258",
		},
		{
			name: "SensorData",
			payload: SensorData{
				SensorID:  "temp-1",
				Temp:      25.0,
				Precision: 2,
			},
			wantHex: "da67726966a36454656d70f94e406853656e736f7249446674656d702d3169507265636973696f6e02",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// encode
			encoded, err := c.Encode(tt.payload)
			assert.NoError(t, err)
			PrintDiag(encoded)
			assert.Equal(t, tt.wantHex, hex.EncodeToString(encoded))

			// decode
			decoded, err := c.Decode(encoded)
			assert.NoError(t, err)
			assert.Equal(t, tt.payload, decoded)
		})
	}
}

func TestUnknownTag(t *testing.T) {
	// set up a codec without registering any tags
	config := CodecConfig{
		EncOptions: cbor.CoreDetEncOptions(),
		DecOptions: cbor.DecOptions{},
	}
	c, err := NewCodec(config)
	assert.NoError(t, err)

	// Data with unregistered tag (GridTag)
	data, _ := hex.DecodeString("da67726964a26249444201026954696d657374616d701a60359700")
	obj, err := c.Decode(data)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unknown tag")
	content := obj.(cbor.Tag).Content.(map[interface{}]interface{})
	ts := content["Timestamp"].(uint64)
	assert.Equal(t, ts, uint64(1614124800))
}

func TestInvalidStructure(t *testing.T) {
	c := setupCodec(t)

	// Malformed CBOR data
	data := []byte{0xd9, 0xd9, 0xf7, 0xda, 0x67, 0x72, 0x69, 0x64} // truncated
	_, err := c.Decode(data)
	assert.Error(t, err)
}

func TestStringToNumAndNumToString(t *testing.T) {
	tests := []struct {
		input     string
		expectNum uint64
	}{
		{
			input:     "grid",
			expectNum: 0x67726964,
		},
		{
			input:     "hello",
			expectNum: 0x68656c6c6f,
		},
		{
			input:     "",
			expectNum: 0,
		},
		{
			input: "GoLang",
			// 'G'=0x47, 'o'=0x6f, 'L'=0x4c, 'a'=0x61, 'n'=0x6e, 'g'=0x67
			expectNum: 0x476f4c616e67,
		},
	}

	for _, tt := range tests {
		t.Run("StringToNum_"+tt.input, func(t *testing.T) {
			result := StringToNum(tt.input)
			assert.Equal(t, tt.expectNum, result, "StringToNum(%q) should be %x", tt.input, tt.expectNum)
		})

		t.Run("NumToString_"+tt.input, func(t *testing.T) {
			result := NumToString(tt.expectNum)
			assert.Equal(t, tt.input, result, "NumToString(%x) should be %q", tt.expectNum, tt.input)
		})
	}

	// Additional round-trip test: converting a string to number and back should yield the original string.
	stringsToTest := []string{"testing", "123abc", "CBOR", "Go", ""}
	for _, s := range stringsToTest {
		t.Run("RoundTrip_"+s, func(t *testing.T) {
			num := StringToNum(s)
			str := NumToString(num)
			assert.Equal(t, s, str, "Round-trip conversion failed for %q", s)
		})
	}
}

func TestRegisterTagName(t *testing.T) {
	config := CodecConfig{
		EncOptions: cbor.CoreDetEncOptions(),
		DecOptions: cbor.DecOptions{},
	}
	c, err := NewCodec(config)
	assert.NoError(t, err)

	tagName := "example"
	expectedTag := StringToNum(tagName)
	type TestPayload struct {
		Value string
	}
	payload := TestPayload{Value: "hello"}

	// Register using tag name
	err = c.RegisterTagName(tagName, payload)
	assert.NoError(t, err)

	// Verify that the tag number is correctly assigned for the payload type.
	gotTag := c.GetTagForType(payload)
	assert.Equal(t, expectedTag, gotTag, "RegisterTagName did not assign the expected tag number")

	// Encode the payload and then decode it to ensure full round-trip functionality.
	encoded, err := c.Encode(payload)
	assert.NoError(t, err)
	decoded, err := c.Decode(encoded)
	assert.NoError(t, err)
	assert.Equal(t, &payload, decoded, "Decoded payload does not match the original")
}
-------------------------------------------------

───────────────────────────── Summary ─────────────────────────────

• If you are writing tests within the same package, remove the extra import.
• If you need to import the codec package from elsewhere, make sure that your module is set up (via go.mod) and update the import path accordingly.

Choose the option that best fits your project setup, and the error should be resolved.