<think>
Okay, I need to add a few slides at the beginning of slides.md that describe PromiseGrid as a decentralized message-passing microkernel architecture and explain why the wire protocol is important. Let me start by understanding the user's request.

The user wants slides covering:
- PromiseGrid's intent as a decentralized virtual machine
- Conventional kernels
- Microkernels
- Message-passing IPC in microkernels
- How PromiseGrid is a decentralized message-passing microkernel

Each slide should have summary bullet points first, then explanatory sentences. I should look at existing slides for examples of structure and formatting.

Looking at the existing slides.md, the first slide is a title slide. The new slides should go after that but before the existing content. So I'll insert the new slides right after the title.

First, I'll outline each new slide:

1. **PromiseGrid Vision: Decentralized Virtual Machine**
   - Intent: Decentralized VM with message-passing
   - Nodes as independent agents
   - Wire protocol critical for interoperability

2. **Conventional Operating System Kernels**
   - Monolithic vs Microkernels
   - Monolithic: All services in kernel space
   - Microkernel: Minimal core, services in user space

3. **Microkernel Message-Passing IPC**
   - IPC via message passing
   - Benefits: Isolation, security, modularity

4. **PromiseGrid as Decentralized Microkernel**
   - Extends microkernel concepts to network
   - Agents as isolated components
   - Wire protocol as the IPC mechanism

5. **Why Wire Protocol Matters**
   - Ensures compatibility across devices
   - Critical for security and trust
   - Foundation for decentralized coordination

I need to ensure each slide follows the structure: bullet points first, then explanations. Also, check for consistency with existing slides' formatting and language.

Now, I'll draft each slide's content, making sure lines are wrapped at 70 characters. Avoid markdown syntax beyond headers and bullet points. Use the same syntax as existing slides.

After drafting, I'll insert these slides after the title slide in slides.md, ensuring the rest of the content follows correctly. Check for any line breaks or formatting issues to maintain consistency.

Finally, verify that the changes are correctly placed and that the regular expression in the response matches the required format for file submission.
</think>

File: /home/stevegt/lab/grid-poc/x/wire/slides/slides.md
```markdown
class: center, middle

# PromiseGrid Wire Protocol Design

---

## PromiseGrid Vision: Decentralized Virtual Machine
### Message-Passing Microkernel Architecture
- Distributed system as coordinated message processors
- Nodes maintain isolated execution environments
- Wire protocol enables cross-environment interoperability

PromiseGrid implements a decentralized virtual machine where agents
exchange messages through a microkernel-inspired architecture. The
wire protocol serves as the foundational layer for secure, versioned
communication between heterogeneous components.

---

## Conventional Operating System Kernels
### Monolithic vs. Microkernel Design
- Monolithic: All services run in kernel space
- Microkernel: Minimal core with user-space services
- Message-passing IPC enables microkernel isolation

Traditional kernels manage hardware resources directly. Microkernels
like Mach and L4 move services (filesystems, drivers) to user space,
communicating via structured message passing rather than system calls.

---

## Microkernel Message-Passing IPC
### Key Characteristics
- Formal message structure definitions
- Process isolation through memory protection
- Synchronous and asynchronous communication modes
- Capability-based security model

Inter-process communication (IPC) in microkernels uses strongly-typed
messages that traverse protected channels. This prevents fault
propagation while enabling component replacement without system
reboots.

---

## PromiseGrid as Decentralized Microkernel
### Network-Scale Architecture
- Agents = isolated "processes" in network space
- Wire protocol = distributed IPC mechanism
- Content addressing = process identifier system

Extends microkernel concepts to networked environments using
content-addressable messages. Agents maintain execution sandboxes
(WASM, containers) while coordinating through verifiable message
exchanges.

---

## Why Wire Protocol Design Matters
### Foundation for Decentralized Coordination
- Versioning through protocol CIDs prevents "dependency hell"
- Cryptographic integrity enables zero-trust operation
- Minimal overhead supports IoT/edge participation

A poorly designed wire protocol could lead to:
- Version incompatibilities
- Security vulnerabilities
- Centralization pressures
- IoT exclusion through bloat

---

## Protocol Overview
### Decentralized Message Passing Architecture
- Microkernel-inspired design for sandbox orchestration
- Content-addressable network using IPFS multihash/CID standards
- Two-phase message structure: protocol hash and payload

A 'CID' (Content Identifier) is a unique identifier for content in
IPFS and compatible systems, including Bluesky.  

The protocol hash serves as a versioning mechanism, enabling future
updates without breaking existing implementations.

---

## Key Design Goals
- Future-proof extensibility through hash of protocol documents
- IoT compatibility with minimal message overhead
- Cross-platform execution (WASM, CLI, containers, bare metal)

---

## Core Protocol Components
### Message Structure
- Nested CBOR format
  - `grid` tag (0x67726964)
    - Protocol hash CID
    - Message payload

Tag 0x67726964 ("grid") will be registered with IANA.

The format of the message payload is described in the document(s)
referred to by the protocol hash CID. 

---

## Content Addressing
- CIDv1 implementation using multiformats standards:
  - Multihash (SHA2-256 default)
  - Multicodec (raw bytes)
  - Multibase encoding
- Protocol documents would typically be stored in IPFS DAGs for ease
  of retrieval by developers.

---

## Cryptographic Foundations
- Public key infrastructure integrated with CIDs
- Multihash-derived addresses for agent identification
  - TBD whether we use Bluesky-style DIDs or IPFS-style CIDs

---

## What is an agent?

An agent is defined as an entity that can:

- cryptographically sign and send messages
- receive and verify the cryptographic signatures of messages

Agents can be humans, machines, or software processes.

This definition of 'agent' is consistent with that of Promise Theory
(PT) in that "agents cannot make promises on behalf of other agents".

---

## PromiseGrid Agents are a subset of Promise Theory Agents

As PromiseGrid (PG) is a practical implementation of Promise Theory,
the engineering constraints involved in building network and security
protocols mean that we need to choose a reasonable subset of Promise
Theory's definition of an agent.  In particular:

- A simple machine or subatomic particle does not have the mechanisms
  required to cryptographically sign or verify messages.
  - So a PG agent cannot be a simple machine or subatomic particle.

This diverges from Promise Theory's definition of an agent.  From the
book "Thinking in Promises", page 9:

  Any agent (person, object, or machine) can harbour intentions. An
  intention might be something like “be red” for a [simple] light
  [...] When an intention is publicly declared to an audience (called
  its scope) it then becomes a promise.

---

## IoT Integration Strategy
### Constrained Device Support
- Example minimum viable agent requirements:
  - Aruino UNO
    - 32KB RAM
    - ability to run sha256 hash algorithm
    - ability to run ed25519 signature algorithm

---

## Decentralized IoT Standard

Is is possible that the grid could serve as a generic IoT network
fabric similar in spirit to the local I2C bus?

- Comparative analysis with MQTT/HTTP bridges
- Grid-as-backbone architecture vs traditional IoT hubs

---

## Next steps

A reasonable next step is to implement a 'hello world' equivalent; an
example of remote execution of a simple function in a CLI demo:

- sender writes a simple WASM module that returns a 'hello world' string
- sender compiles the module and stores it in IPFS, retaining the CID
  of  the module
- sender includes the CID in a message to a recipient
- recipient retrieves the module from IPFS using the CID
- recipient executes the module in a WASM runtime, seeing 'hello world'

---

## Standardization Roadmap

Register 'grid' tag with IANA.

Create protocol documents that can be stored in IPFS and referenced by
the protocol hash CID.  For example:

- Scenario tree modeling
- Personal currencies
- Advisor/Executor model
- ...

Start a draft RFC.
```
EOF_/home/stevegt/lab/grid-poc/x/wire/slides/slides.md

<references>
</references>
