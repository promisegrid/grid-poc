<think>
Okay, let's tackle this problem. The user is encountering a Go module error where the package github.com/ipfs/boxo/config isn't found in the latest version of boxo (v0.29.1). The error message indicates that the code is importing that package, but it doesn't exist in the module.

First, I need to figure out why the package is missing. Looking at the provided search results, especially [4] and [9], I see that Boxo is a collection of libraries from various IPFS Go modules. The issue in [9] mentions migrating repositories into Boxo. Maybe the config package was moved or renamed.

In the code, the import is "github.com/ipfs/boxo/config". Checking the Boxo documentation [4], the config package isn't listed under the migrated components. Instead, the Kubo (go-ipfs) repository [1][6] has a config package. The user's code is using Kubo's repo package, so perhaps the config should come from Kubo as well.

Looking at the setupRepo function, it uses config.Init from Boxo. But according to the search results, the config initialization is part of Kubo. The correct package should be from Kubo, not Boxo. So the import should be changed from "github.com/ipfs/boxo/config" to "github.com/ipfs/kubo/config".

Next, I need to check if the Kubo config package's Init function matches the usage in the code. The user's code calls config.Init(os.Stdout, 2048), which aligns with Kubo's config.Init function that takes an io.Writer and a keysize. Boxo's config might have a different API or might not exist anymore.

Additionally, the code uses repo.Mock from Kubo, which is correct. So replacing the Boxo config import with Kubo's config should resolve the missing package error. 

Another thing to verify is the module dependencies. The user might need to ensure that the Kubo module is properly required in go.mod. Since the code already imports "github.com/ipfs/kubo/repo", adding the config package from the same module should be compatible.

So the fix involves changing the import path in the code from github.com/ipfs/boxo/config to github.com/ipfs/kubo/config. This should resolve the module error as the config package is part of Kubo, not Boxo.
</think>

File: /home/stevegt/lab/grid-poc/x/node-boxo/node-boxo.go
```go
package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/ipfs/boxo/bitswap"
	"github.com/ipfs/boxo/bitswap/network"
	"github.com/ipfs/boxo/blockstore"
	"github.com/ipfs/boxo/exchange"
	"github.com/ipfs/boxo/ipns"
	"github.com/ipfs/boxo/provider"
	flatfs "github.com/ipfs/go-ds-flatfs"
	"github.com/ipfs/kubo/config"
	"github.com/ipfs/kubo/repo"
	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p-kad-dht/dual"
	pubsub "github.com/libp2p/go-libp2p-pubsub"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/routing"
)

const repoPath = "/tmp/.ipfs-boxo"

type BoxoNode struct {
	Host          host.Host
	DHT           *dual.DHT
	PubSub        *pubsub.PubSub
	Blockstore    blockstore.Blockstore
	Bitswap       exchange.Interface
	IPNSPublisher *ipns.Publisher
}

func setupRepo(ctx context.Context, path string) (repo.Repo, error) {
	if err := os.MkdirAll(path, 0755); err != nil {
		return nil, fmt.Errorf("creating repo directory: %w", err)
	}

	cfg, err := config.Init(os.Stdout, 2048)
	if err != nil {
		return nil, fmt.Errorf("initializing config: %w", err)
	}

	cfg.Datastore.Spec = map[string]interface{}{
		"type":      "flatfs",
		"path":      "blocks",
		"sync":      true,
		"shardFunc": "/repo/flatfs/shard/v1/next-to-last/2",
	}

	return &repo.Mock{
		D: flatfs.CreateOrOpen(flatfs.ParseShardFunc(cfg.Datastore.Spec["shardFunc"].(string)),
			filepath.Join(path, "blocks"), false),
		C: *cfg,
	}, nil
}

func NewBoxoNode(ctx context.Context) (*BoxoNode, error) {
	repo, err := setupRepo(ctx, repoPath)
	if err != nil {
		return nil, fmt.Errorf("repo setup failed: %w", err)
	}

	hst, err := libp2p.New(
		libp2p.ListenAddrStrings(
			"/ip4/0.0.0.0/tcp/4001",
			"/ip6/::/tcp/4001",
		),
		libp2p.NATPortMap(),
	)
	if err != nil {
		return nil, fmt.Errorf("creating host: %w", err)
	}

	dht, err := dual.New(ctx, hst,
		dual.WanDHTOption(dual.DHTClientMode()),
		dual.LanDHTOption(dual.DHTClientMode()),
	)
	if err != nil {
		return nil, fmt.Errorf("creating DHT: %w", err)
	}

	ps, err := pubsub.NewGossipSub(ctx, hst)
	if err != nil {
		return nil, fmt.Errorf("creating pubsub: %w", err)
	}

	bs := blockstore.NewBlockstore(repo.Datastore())
	bswap := bitswap.New(ctx,
		network.NewFromIpfsHost(hst, dht),
		bs,
		bitswap.ProvideEnabled(true),
		bitswap.EngineBlockstoreWorkerCount(3),
	)

	ipnsPublisher, err := ipns.NewPublisher(hst.Peerstore(), repo.Datastore(), routing.NewComposer(routing.NewDHTRouting(dht.WAN, nil)))
	if err != nil {
		return nil, fmt.Errorf("creating IPNS publisher: %w", err)
	}

	return &BoxoNode{
		Host:          hst,
		DHT:           dht,
		PubSub:        ps,
		Blockstore:    bs,
		Bitswap:       bswap,
		IPNSPublisher: ipnsPublisher,
	}, nil
}

func (n *BoxoNode) Start(ctx context.Context) error {
	if err := n.DHT.Bootstrap(ctx); err != nil {
		return fmt.Errorf("dht bootstrap failed: %w", err)
	}

	cfg, _ := config.Init(os.Stdout, 2048)
	peers, err := cfg.BootstrapPeers()
	if err != nil {
		return fmt.Errorf("getting bootstrap peers: %w", err)
	}

	for _, p := range peers {
		if err := n.Host.Connect(ctx, p); err != nil {
			fmt.Printf("Failed to connect to bootstrap peer %s: %v\n", p.ID, err)
		}
	}

	provider.NewProviderSystem(n.Host, n.DHT, n.Blockstore)
	return nil
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	node, err := NewBoxoNode(ctx)
	if err != nil {
		panic(fmt.Errorf("node creation failed: %w", err))
	}

	if err := node.Start(ctx); err != nil {
		panic(fmt.Errorf("node start failed: %w", err))
	}
	defer node.Host.Close()

	fmt.Printf("IPFS node running with ID %s\n", node.Host.ID())
	fmt.Printf("Listening on addresses:\n")
	for _, addr := range node.Host.Addrs() {
		fmt.Printf("  %s/p2p/%s\n", addr, node.Host.ID())
	}

	go func() {
		time.Sleep(5 * time.Second)
		value := []byte("/ipfs/QmExampleContentHash")

		expiration := time.Now().Add(24 * time.Hour)
		err := node.IPNSPublisher.Publish(ctx, node.Host.Peerstore().PrivKey(node.Host.ID()), ipns.Record{
			Value:    value,
			Validity: expiration,
		})
		if err != nil {
			fmt.Printf("IPNS publication failed: %v\n", err)
		} else {
			fmt.Println("Successfully published IPNS record")
		}
	}()

	select {}
}
```
EOF_/home/stevegt/lab/grid-poc/x/node-boxo/node-boxo.go

<references>
[1] https://github.com/ipfs/kubo/blob/master/docs/config.md
[2] https://docs.ipfs.eth.link/how-to/configure-node/
[3] https://git.shivering-isles.com/github-mirror/ipfs/go-ipfs/-/blob/v0.26.0/docs/environment-variables.md
[4] https://github.com/ipfs/boxo
[5] https://github.com/kubernetes/client-go/issues/551
[6] https://github.com/ipfs/kubo
[7] https://github.com/ipfs/go-ipfs-util
[8] https://github.com/ipfs/go-ipfs-api
[9] https://github.com/ipfs/boxo/issues/215
[10] https://docs.ipfs.tech/reference/kubo/cli/
[11] https://newreleases.io/project/github/ipfs/kubo/release/v0.30.0
[12] https://github.com/ipfs/ipfs-desktop/blob/master/README.md
</references>
