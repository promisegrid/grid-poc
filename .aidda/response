File: /home/stevegt/lab/grid-poc/x/git-cbor/main.go
```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fxamacker/cbor/v2"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/filemode"
	"github.com/go-git/go-git/v5/plumbing/object"

	. "github.com/stevegt/goadapt"
)

// CommitData represents the structure of a commit in CBOR format.
type CommitData struct {
	Hash           string     `cbor:"hash"`
	Tree           string     `cbor:"tree"`
	Parents        []string   `cbor:"parents"`
	AuthorName     string     `cbor:"author_name"`
	AuthorEmail    string     `cbor:"author_email"`
	AuthorDate     time.Time  `cbor:"author_date"`
	CommitterName  string     `cbor:"committer_name"`
	CommitterEmail string     `cbor:"committer_email"`
	CommitterDate  time.Time  `cbor:"committer_date"`
	Message        string     `cbor:"message"`
	Trees          []TreeData `cbor:"trees"`
	Blobs          []BlobData `cbor:"blobs"`
}

...

// git2cbor converts a git commit object to CBOR format, including new and changed tree and blob objects.
func git2cbor(ref string) {
	// Find the Git repository directory by walking up the directory tree
	repoPath, err := findGitRepo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding .git directory: %v\n", err)
		os.Exit(1)
	}

	// Open the Git repository
	repo, err := git.PlainOpen(repoPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error opening repository: %v\n", err)
		os.Exit(1)
	}

	// Resolve the reference to a commit hash
	hash, err := repo.ResolveRevision(plumbing.Revision(ref))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error resolving ref '%s': %v\n", ref, err)
		os.Exit(1)
	}

	// Get the commit object from the hash
	commit, err := repo.CommitObject(*hash)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error retrieving commit object: %v\n", err)
		os.Exit(1)
	}

	// Populate the CommitData struct without setting the Hash
	commitData := CommitData{
		Tree:           commit.TreeHash.String(),
		Parents:        make([]string, len(commit.ParentHashes)),
		AuthorName:     commit.Author.Name,
		AuthorEmail:    commit.Author.Email,
		AuthorDate:     commit.Author.When,
		CommitterName:  commit.Committer.Name,
		CommitterEmail: commit.Committer.Email,
		CommitterDate:  commit.Committer.When,
		Message:        commit.Message,
		Trees:          []TreeData{},
		Blobs:          []BlobData{},
	}

	Assert(commitData.Tree == commit.TreeHash.String(), "Tree hash mismatch")

	for i, parentHash := range commit.ParentHashes {
		commitData.Parents[i] = parentHash.String()
	}

	// Collect trees from parent commits
	parentTrees, err := collectParentTrees(repo, commit)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error collecting parent trees: %v\n", err)
		os.Exit(1)
	}

	// Collect new and changed tree objects
	if err := collectNewAndChangedTrees(repo, commit.TreeHash, &commitData.Trees, parentTrees); err != nil {
		fmt.Fprintf(os.Stderr, "Error collecting tree objects: %v\n", err)
		os.Exit(1)
	}

	// Collect blob objects from the new and changed trees
	if err := collectBlobs(repo, commit.TreeHash, &commitData.Blobs); err != nil {
		fmt.Fprintf(os.Stderr, "Error collecting blob objects: %v\n", err)
		os.Exit(1)
	}

	// Encode the CommitData to CBOR without the Hash
	cborBytesWithoutHash, err := cbor.Marshal(commitData)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding commit data to CBOR: %v\n", err)
		os.Exit(1)
	}

	// Calculate the SHA-256 hash of the CBOR data
	hashBytes := sha256.Sum256(cborBytesWithoutHash)
	commitData.Hash = hex.EncodeToString(hashBytes[:])

	// Encode the CommitData to CBOR again, now including the Hash
	cborBytes, err := cbor.Marshal(commitData)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding commit data with hash to CBOR: %v\n", err)
		os.Exit(1)
	}

	// Write the CBOR data to stdout
	_, err = os.Stdout.Write(cborBytes)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing CBOR to stdout: %v\n", err)
		os.Exit(1)
	}
}

...

// cbor2git converts CBOR data to a git commit object, including tree and blob objects.
func cbor2git() {
	// Read CBOR data from stdin
	cborData, err := io.ReadAll(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading CBOR data: %v\n", err)
		os.Exit(1)
	}

	// Decode CBOR data into CommitData
	var commitData CommitData
	err = cbor.Unmarshal(cborData, &commitData)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error decoding CBOR data: %v\n", err)
		os.Exit(1)
	}

	// Find the Git repository directory by walking up the directory tree
	repoPath, err := findGitRepo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding .git directory: %v\n", err)
		os.Exit(1)
	}

	// Open the Git repository
	repo, err := git.PlainOpen(repoPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error opening repository: %v\n", err)
		os.Exit(1)
	}

	// Write blob objects to the repository
	for _, blobData := range commitData.Blobs {
		if err := writeBlobToRepo(repo, blobData); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing blob '%s' to repository: %v\n", blobData.Hash, err)
			os.Exit(1)
		}
	}

	// Write tree objects to the repository
	for _, treeData := range commitData.Trees {
		if err := writeTreeToRepo(repo, treeData); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing tree '%s' to repository: %v\n", treeData.Hash, err)
			os.Exit(1)
		}
	}

	// Prepare parent commits
	var parentCommits []*object.Commit
	for _, ph := range commitData.Parents {
		pHash := plumbing.NewHash(ph)
		parentCommit, err := repo.CommitObject(pHash)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error retrieving parent commit '%s': %v\n", ph, err)
			os.Exit(1)
		}
		parentCommits = append(parentCommits, parentCommit)
	}

	// Prepare the tree
	treeHash := plumbing.NewHash(commitData.Tree)
	_, err = repo.TreeObject(treeHash)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error retrieving tree object: %v\n", err)
		os.Exit(1)
	}

	// Create author and committer signatures
	author := &object.Signature{
		Name:  commitData.AuthorName,
		Email: commitData.AuthorEmail,
		When:  commitData.AuthorDate,
	}
	committer := &object.Signature{
		Name:  commitData.CommitterName,
		Email: commitData.CommitterEmail,
		When:  commitData.CommitterDate,
	}

	// Prepare parent hashes
	parentHashes := parentCommitHashes(parentCommits)

	// Create the commit object
	commit := &object.Commit{
		Author:       *author,
		Committer:    *committer,
		Message:      commitData.Message,
		TreeHash:     treeHash,
		ParentHashes: parentHashes,
	}

	// Encode the CommitData to CBOR without the Hash for verification
	commitDataForHash := commitData
	commitDataForHash.Hash = ""
	cborBytesForHash, err := cbor.Marshal(commitDataForHash)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding commit data for hash calculation: %v\n", err)
		os.Exit(1)
	}

	// Calculate the SHA-256 hash of the CBOR data
	hashBytes := sha256.Sum256(cborBytesForHash)
	computedHash := hex.EncodeToString(hashBytes[:])

	// Verify that the computed hash matches the provided hash
	if computedHash != commitData.Hash {
		fmt.Fprintf(os.Stderr, "Computed hash '%s' does not match provided hash '%s'\n", computedHash, commitData.Hash)
		os.Exit(1)
	}

	// Write the commit object to the repository
	err = writeCommitToRepo(repo, commit)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing commit to repository: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully stored commit %s\n", computedHash)
}
```
EOF_/home/stevegt/lab/grid-poc/x/git-cbor/main.go