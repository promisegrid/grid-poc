File: /home/stevegt/lab/grid-poc/x/sim1/README.md
```markdown
# PromiseGrid Simulation (sim1)

A demonstration of three agents hosted on separate nodes that communicate via
persistent TCP connections using the PromiseGrid protocol pattern.

## Overview

This simulation shows three Go nodes (node1, node2, and node3) each hosting
an agent (agent1, agent2, and agent3 respectively) that exchange CBOR-encoded
messages through a kernel layer that manages network connections and message
routing. Key features:

- Persistent TCP connections with automatic reconnection
- CID-based protocol subscriptions
- Asynchronous message handling
- Bi-directional communication over multiple TCP connections maintained
  in a map for dynamic routing

## Components

### wire Package
- Defines Message struct with protocol CID and payload
- CBOR serialization/deserialization with deterministic encoding
- Custom CBOR tag (0x67726964) for message structure

### kernel Package
- Manages network connections using a map of active connections
- Handles message routing to protocol handlers
- Provides publish/subscribe interface to agents
- Multiple active TCP connections maintained between peers
- Automatic connection failover and reconnection

### Agents (Library Packages)
- agent1: Initiates conversation by dialing peer (node2) and sending a
  request with the payload "hello from agent1".
- agent2: Listens for connections from agent1 and agent3 (on node2) and upon
  receiving a request, sends a response "hello back from agent2" using the same
  TCP connection.
- agent3: Also initiates conversation by dialing peer (node2) and sending a
  request with the payload "hello from agent3".

### Nodes (Executable Binaries)
Each node hosts one agent instance. The main functions now reside in the node
packages.
- node1: Hosts agent1. It dials agent2 at the specified peer address.
- node2: Hosts agent2. It listens on a configurable TCP port.
- node3: Hosts agent3. It dials agent2 at the specified peer address.

## How It Works

1. Nodes are started. node1 and node3 will dial node2 while node2 accepts
   incoming connections.
2. The kernel maintains multiple persistent TCP connections between the nodes.
3. Message flow:
   - Agent1 sends a "hello from agent1" request every second via its outbound
     connection.
   - Agent3 sends a "hello from agent3" request every second via its outbound
     connection.
   - Agent2 receives requests on the accepted TCP connections and sends a
     "hello back from agent2" response using the same connection that was used
     to receive the request.
   - Agents receive responses on the connection they used to send the request
     and print them to stdout.

## Running the Simulation

### Setup
1. In terminal 1 (node1 hosting agent1):
```bash
cd node1
go run node1.go -peer localhost:7272
```

2. In terminal 2 (node2 hosting agent2):
```bash
cd node2
go run node2.go -port 7272
```

3. In terminal 3 (node3 hosting agent3):
```bash
cd node3
go run node3.go -peer localhost:7272
```

### Expected Output

**Node1 (hosting Agent1):**
```
Node1 (hosting Agent1) running. Press Ctrl+C to exit...
Agent1 received: hello back from agent2
```

**Node2 (hosting Agent2):**
```
Node2 (hosting Agent2) running. Press Ctrl+C to exit...
Agent2 received: hello from agent1
Agent2 received: hello from agent3
```

**Node3 (hosting Agent3):**
```
Node3 (hosting Agent3) running. Press Ctrl+C to exit...
Agent3 received: hello back from agent2
```

## Notes

- Protocol CIDs are hardcoded for demonstration:
  - Request protocol:
    bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny
  - Response protocol:
    bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu
- The kernel automatically reconnects if a TCP connection drops.
- Press Ctrl+C in any terminal to gracefully shut down the node.
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/README.md

File: /home/stevegt/lab/grid-poc/x/sim1/agent1/agent1.go
```go
package agent1

import (
	"fmt"
	"log"
	"time"

	"sim1/kernel"
	"sim1/wire"

	"github.com/ipfs/go-cid"
)

// Request protocol used to send messages to agent2.
var requestProtocolStr = "bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny"

// Response protocol expected from agent2.
var responseProtocolStr = "bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu"

// Start initializes Agent1 with the given peer address and begins sending
// messages every second. It returns a stop function to gracefully shut down the
// agent.
func Start(peer string) (func(), error) {
	reqCid, err := cid.Decode(requestProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid request protocol CID: %v", err)
	}

	respCid, err := cid.Decode(responseProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid response protocol CID: %v", err)
	}

	k := kernel.NewKernel()
	k.SetPeer(peer)

	err = k.Start(0)
	if err != nil {
		return nil, fmt.Errorf("kernel start failed: %v", err)
	}

	// Subscribe to response protocol to receive replies.
	k.Subscribe(respCid, func(msg wire.Message) {
		fmt.Println("Agent1 received:", string(msg.Payload))
	})

	done := make(chan struct{})

	go func() {
		// Send messages every second.
		payload := []byte("hello from agent1")
		timer := time.NewTicker(1 * time.Second)
		defer timer.Stop()
		for {
			select {
			case <-done:
				fmt.Println("Agent1 stopping...")
				return
			case <-timer.C:
				err = k.Publish(wire.Message{
					Protocol: reqCid.Bytes(),
					Payload:  payload,
				})
				if err != nil {
					log.Printf("Agent1 publish failed: %v", err)
				}
			}
		}
	}()

	stop := func() {
		close(done)
		time.Sleep(2 * time.Second)
		k.Stop()
	}

	return stop, nil
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/agent1/agent1.go

File: /home/stevegt/lab/grid-poc/x/sim1/agent2/agent2.go
```go
package agent2

import (
	"fmt"
	"log"

	"sim1/kernel"
	"sim1/wire"

	"github.com/ipfs/go-cid"
)

// Request protocol expected on incoming messages from agent1 and agent3.
var requestProtocolStr = "bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny"

// Response protocol used to reply to agent1 and agent3.
var responseProtocolStr = "bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu"

// Start initializes Agent2 to listen on the given port. It returns a stop
// function to gracefully shut down the agent.
func Start(port int) (func(), error) {
	reqCid, err := cid.Decode(requestProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid request protocol CID: %v", err)
	}

	respCid, err := cid.Decode(responseProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid response protocol CID: %v", err)
	}

	k := kernel.NewKernel()

	err = k.Start(port)
	if err != nil {
		return nil, fmt.Errorf("kernel start failed: %v", err)
	}

	// Subscribe to the request protocol. Upon receiving a message, send a reply
	// using the same TCP connection.
	k.Subscribe(reqCid, func(msg wire.Message) {
		fmt.Println("Agent2 received:", string(msg.Payload))
		err := k.Publish(wire.Message{
			Protocol: respCid.Bytes(),
			Payload:  []byte("hello back from agent2"),
		})
		if err != nil {
			log.Printf("Agent2 response send failed: %v", err)
		}
	})

	stop := func() {
		k.Stop()
	}

	return stop, nil
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/agent2/agent2.go

File: /home/stevegt/lab/grid-poc/x/sim1/agent3/agent3.go
```go
package agent3

import (
	"fmt"
	"log"
	"time"

	"sim1/kernel"
	"sim1/wire"

	"github.com/ipfs/go-cid"
)

// Request protocol used to send messages to agent2.
var requestProtocolStr = "bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny"

// Response protocol expected from agent2.
var responseProtocolStr = "bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu"

// Start initializes Agent3 with the given peer address and begins sending
// messages every second. It returns a stop function to gracefully shut down the
// agent.
func Start(peer string) (func(), error) {
	reqCid, err := cid.Decode(requestProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid request protocol CID: %v", err)
	}

	respCid, err := cid.Decode(responseProtocolStr)
	if err != nil {
		return nil, fmt.Errorf("invalid response protocol CID: %v", err)
	}

	k := kernel.NewKernel()
	k.SetPeer(peer)

	err = k.Start(0)
	if err != nil {
		return nil, fmt.Errorf("kernel start failed: %v", err)
	}

	// Subscribe to response protocol to receive replies.
	k.Subscribe(respCid, func(msg wire.Message) {
		fmt.Println("Agent3 received:", string(msg.Payload))
	})

	done := make(chan struct{})

	go func() {
		// Send messages every second.
		payload := []byte("hello from agent3")
		timer := time.NewTicker(1 * time.Second)
		defer timer.Stop()
		for {
			select {
			case <-done:
				fmt.Println("Agent3 stopping...")
				return
			case <-timer.C:
				err = k.Publish(wire.Message{
					Protocol: reqCid.Bytes(),
					Payload:  payload,
				})
				if err != nil {
					log.Printf("Agent3 publish failed: %v", err)
				}
			}
		}
	}()

	stop := func() {
		close(done)
		time.Sleep(2 * time.Second)
		k.Stop()
	}

	return stop, nil
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/agent3/agent3.go

File: /home/stevegt/lab/grid-poc/x/sim1/node1/node1.go
```go
package main

import (
	"flag"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"sim1/agent1"
)

func main() {
	peer := flag.String("peer", "localhost:7272", "peer address for dialing")
	flag.Parse()

	stop, err := agent1.Start(*peer)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error starting Agent1:", err)
		os.Exit(1)
	}

	fmt.Println("Node1 (hosting Agent1) running. Press Ctrl+C to exit...")
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	stop()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/node1/node1.go

File: /home/stevegt/lab/grid-poc/x/sim1/node2/node2.go
```go
package main

import (
	"flag"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"sim1/agent2"
)

func main() {
	port := flag.Int("port", 7272, "listen port for node2")
	flag.Parse()

	stop, err := agent2.Start(*port)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error starting Agent2:", err)
		os.Exit(1)
	}

	fmt.Println("Node2 (hosting Agent2) running. Press Ctrl+C to exit...")
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	stop()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/node2/node2.go

File: /home/stevegt/lab/grid-poc/x/sim1/node3/node3.go
```go
package main

import (
	"flag"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"sim1/agent3"
)

func main() {
	peer := flag.String("peer", "localhost:7272", "peer address for dialing")
	flag.Parse()

	stop, err := agent3.Start(*peer)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error starting Agent3:", err)
		os.Exit(1)
	}

	fmt.Println("Node3 (hosting Agent3) running. Press Ctrl+C to exit...")
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	stop()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/node3/node3.go