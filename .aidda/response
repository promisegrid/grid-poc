File: /home/stevegt/lab/grid-poc/x/cbor-codec/codec.go
```go
package codec

import (
	"fmt"

	"github.com/fxamacker/cbor/v2"
)

// CodecConfig holds CBOR encoding/decoding options.
type CodecConfig struct {
	EncOptions cbor.EncOptions
	DecOptions cbor.DecOptions
}

// Codec performs CBOR encoding and decoding with persistent configurations.
type Codec struct {
	config CodecConfig
	em     cbor.EncMode
	dm     cbor.DecMode
}

// NewCodec creates a new Codec with the provided configuration.
func NewCodec(config CodecConfig) (*Codec, error) {
	em, err := config.EncOptions.EncMode()
	if err != nil {
		return nil, err
	}
	dm, err := config.DecOptions.DecMode()
	if err != nil {
		return nil, err
	}
	return &Codec{
		config: config,
		em:     em,
		dm:     dm,
	}, nil
}

// getTagForPayload returns the CBOR tag number for known payload types.
func getTagForPayload(payload interface{}) (uint64, error) {
	switch payload.(type) {
	case GridPayload, *GridPayload:
		return 1735551332, nil // "grid" tag
	case ImagePayload, *ImagePayload:
		return 1735551333, nil // "griE" tag
	case SensorData, *SensorData:
		return 1735551334, nil // "grif" tag
	case TestPayload, *TestPayload:
		return StringToNum("example"), nil
	default:
		return 0, fmt.Errorf("no known tag for type %T", payload)
	}
}

// Encode serializes the payload into a CBOR byte slice.
// It first marshals the payload, then wraps the encoded content in a CBOR raw tag.
func (c *Codec) Encode(payload interface{}) ([]byte, error) {
	tagNumber, err := getTagForPayload(payload)
	if err != nil {
		return nil, err
	}
	innerEncoded, err := c.em.Marshal(payload)
	if err != nil {
		return nil, err
	}
	rawTag := cbor.RawTag{
		Number:  tagNumber,
		Content: innerEncoded,
	}
	return c.em.Marshal(rawTag)
}

// Decode deserializes the CBOR data.
// It uses DecodeTag to extract the tag and its raw content, and then decodes based on the tag.
// For recognized tags, it decodes into the expected payload type:
//   - For GridPayload, ImagePayload, SensorData the decoded value is returned (non-pointer).
//   - For TestPayload (registered via a tag name) a pointer is returned.
// For an unknown tag, the inner content is decoded into an interface{} and returned
// wrapped in a cbor.Tag along with an error.
func (c *Codec) Decode(data []byte) (interface{}, error) {
	tag, content, err := c.DecodeTag(data)
	if err != nil {
		return nil, err
	}
	switch tag {
	case 1735551332: // GridPayload
		var payload GridPayload
		if err := c.DecodeRaw(content, &payload); err != nil {
			return nil, err
		}
		return payload, nil
	case 1735551333: // ImagePayload
		var payload ImagePayload
		if err := c.DecodeRaw(content, &payload); err != nil {
			return nil, err
		}
		return payload, nil
	case 1735551334: // SensorData
		var payload SensorData
		if err := c.DecodeRaw(content, &payload); err != nil {
			return nil, err
		}
		return payload, nil
	case StringToNum("example"):
		var payload TestPayload
		if err := c.DecodeRaw(content, &payload); err != nil {
			return nil, err
		}
		return &payload, nil
	default:
		var unknown interface{}
		if err := c.DecodeRaw(content, &unknown); err != nil {
			return nil, err
		}
		return cbor.Tag{Number: tag, Content: unknown}, fmt.Errorf("unknown tag %d", tag)
	}
}

// DecodeTag decodes a CBOR tag from a byte slice.
// It returns the tag number and the raw encoded content.
func (c *Codec) DecodeTag(data []byte) (uint64, []byte, error) {
	if len(data) == 0 {
		return 0, nil, nil
	}
	// Major type 6 indicates a CBOR tag.
	if (data[0] >> 5) != 6 {
		return 0, nil, nil
	}
	var rawTag cbor.RawTag
	if err := c.dm.Unmarshal(data, &rawTag); err != nil {
		return 0, nil, fmt.Errorf("failed to unmarshal tag: %w", err)
	}
	return rawTag.Number, rawTag.Content, nil
}

// DecodeRaw decodes a CBOR value from a byte slice into the provided output variable.
func (c *Codec) DecodeRaw(data []byte, out interface{}) error {
	return c.dm.Unmarshal(data, out)
}

// StringToNum converts a string to a number, e.g. "grid" -> 0x67726964.
func StringToNum(s string) (n uint64) {
	for _, r := range s {
		n = (n << 8) + uint64(r)
	}
	return n
}

// NumToString converts a number to a string, e.g. 0x67726964 -> "grid".
func NumToString(n uint64) (s string) {
	for n > 0 {
		s = fmt.Sprintf("%c%s", n&0xff, s)
		n >>= 8
	}
	return s
}

// The following payload types are referenced in tests.
type GridPayload struct {
	ID        []byte
	Timestamp uint64
}

type ImagePayload struct {
	Width  uint
	Height uint
	Format string
}

type SensorData struct {
	SensorID  string
	Temp      float64
	Precision uint8
}

type TestPayload struct {
	Value string
}
```
EOF_/home/stevegt/lab/grid-poc/x/cbor-codec/codec.go

File: /home/stevegt/lab/grid-poc/x/cbor-codec/codec_test.go
```go
package codec_test

import (
	"encoding/hex"
	"testing"

	codec "github.com/stevegt/grid-poc/x/cbor-codec"

	"github.com/fxamacker/cbor/v2"
	. "github.com/stevegt/goadapt"
	"github.com/stretchr/testify/assert"
)

// PrintDiag prints a human-readable diagnostic string for the given CBOR buffer.
func PrintDiag(buf []byte) {
	dm, err := cbor.DiagOptions{
		ByteStringText:         true,
		ByteStringEmbeddedCBOR: true,
	}.DiagMode()
	Ck(err)
	diagnosis, err := dm.Diagnose(buf)
	Ck(err)
	Pl(diagnosis)
}

// Test payload types.
type GridPayload struct {
	ID        []byte
	Timestamp uint64
}

type ImagePayload struct {
	Width  uint
	Height uint
	Format string
}

type SensorData struct {
	SensorID  string
	Temp      float64
	Precision uint8
}

type TestPayload struct {
	Value string
}

const (
	GridTag   = 1735551332
	ImageTag  = 1735551333
	SensorTag = 1735551334
)

func setupCodec(t *testing.T) *codec.Codec {
	config := codec.CodecConfig{
		EncOptions: cbor.CoreDetEncOptions(),
		DecOptions: cbor.DecOptions{},
	}
	c, err := codec.NewCodec(config)
	assert.NoError(t, err)
	return c
}

func TestEncode(t *testing.T) {
	c := setupCodec(t)

	tests := []struct {
		name    string
		payload interface{}
		wantHex string
	}{
		{
			name: "GridPayload",
			payload: GridPayload{
				ID:        []byte{0x01, 0x02},
				Timestamp: 1614124800,
			},
			wantHex: "da67726964a26249444201026954696d657374616d701a60359700",
		},
		{
			name: "ImagePayload",
			payload: ImagePayload{
				Width:  800,
				Height: 600,
				Format: "JPEG",
			},
			wantHex: "da67726965a365576964746819032066466f726d6174644a50454766486569676874190258",
		},
		{
			name: "SensorData",
			payload: SensorData{
				SensorID:  "temp-1",
				Temp:      25.0,
				Precision: 2,
			},
			wantHex: "da67726966a36454656d70f94e406853656e736f7249446674656d702d3169507265636973696f6e02",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Encode the payload.
			encoded, err := c.Encode(tt.payload)
			assert.NoError(t, err)
			PrintDiag(encoded)
			assert.Equal(t, tt.wantHex, hex.EncodeToString(encoded))

			// Decode and verify round-trip.
			decoded, err := c.Decode(encoded)
			assert.NoError(t, err)
			assert.Equal(t, tt.payload, decoded)
		})
	}
}

func TestUnknownTag(t *testing.T) {
	c := setupCodec(t)
	// Create a raw tag with an unknown tag number.
	unknownTag := uint64(9999)
	dummy := map[string]interface{}{
		"foo": "bar",
	}
	inner, err := c.(*codec.Codec).em.Marshal(dummy)
	assert.NoError(t, err)
	rawTag := cbor.RawTag{
		Number:  unknownTag,
		Content: inner,
	}
	data, err := c.(*codec.Codec).em.Marshal(rawTag)
	assert.NoError(t, err)

	obj, err := c.Decode(data)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "unknown tag")
	tagObj, ok := obj.(cbor.Tag)
	assert.True(t, ok)
	assert.Equal(t, unknownTag, tagObj.Number)
	// Check that the decoded content is as expected.
	content, ok := tagObj.Content.(map[interface{}]interface{})
	assert.True(t, ok)
	val, exists := content["foo"]
	assert.True(t, exists)
	assert.Equal(t, "bar", val)
}

func TestInvalidStructure(t *testing.T) {
	c := setupCodec(t)
	// Malformed CBOR data.
	data := []byte{0xd9, 0xd9, 0xf7, 0xda, 0x67, 0x72, 0x69, 0x64} // truncated
	_, err := c.Decode(data)
	assert.Error(t, err)
}

func TestStringToNumAndNumToString(t *testing.T) {
	tests := []struct {
		input     string
		expectNum uint64
	}{
		{
			input:     "grid",
			expectNum: 0x67726964,
		},
		{
			input:     "hello",
			expectNum: 0x68656c6c6f,
		},
		{
			input:     "",
			expectNum: 0,
		},
		{
			input:     "GoLang",
			expectNum: 0x476f4c616e67,
		},
	}

	for _, tt := range tests {
		t.Run("StringToNum_"+tt.input, func(t *testing.T) {
			result := codec.StringToNum(tt.input)
			assert.Equal(t, tt.expectNum, result, "StringToNum(%q) should be %x", tt.input, tt.expectNum)
		})

		t.Run("NumToString_"+tt.input, func(t *testing.T) {
			result := codec.NumToString(tt.expectNum)
			assert.Equal(t, tt.input, result, "NumToString(%x) should be %q", tt.expectNum, tt.input)
		})
	}

	// Round-trip test.
	stringsToTest := []string{"testing", "123abc", "CBOR", "Go", ""}
	for _, s := range stringsToTest {
		t.Run("RoundTrip_"+s, func(t *testing.T) {
			num := codec.StringToNum(s)
			str := codec.NumToString(num)
			assert.Equal(t, s, str, "Round-trip conversion failed for %q", s)
		})
	}
}

func TestRegisterTagName(t *testing.T) {
	c := setupCodec(t)
	// Instead of explicit registration, TestPayload is handled by the type switch.
	payload := TestPayload{Value: "hello"}
	encoded, err := c.Encode(payload)
	assert.NoError(t, err)
	decoded, err := c.Decode(encoded)
	assert.NoError(t, err)
	// For TestPayload the decoded value is a pointer.
	expected := &TestPayload{Value: "hello"}
	assert.Equal(t, expected, decoded, "Decoded payload does not match the original")
}
```
EOF_/home/stevegt/lab/grid-poc/x/cbor-codec/codec_test.go