File: /home/stevegt/lab/grid-poc/x/sim1/README.md
```markdown
# PromiseGrid Simulation (sim1)

A demonstration of two agents communicating via persistent TCP connections
using the PromiseGrid protocol pattern.

## Overview

This simulation shows two Go processes (agent1 and agent2) exchanging CBOR-
encoded messages through a kernel layer that manages network connections and
message routing. Key features:

- Persistent TCP connections with automatic reconnection
- CID-based protocol subscriptions
- Asynchronous message handling
- Bi-directional communication over a single TCP connection

## Components

### wire Package
- Defines `Message` struct with protocol CID and payload
- CBOR serialization/deserialization with deterministic encoding
- Custom CBOR tag (0x67726964) for message structure

### kernel Package
- Manages network connections
- Handles message routing to protocol handlers
- Provides publish/subscribe interface to agents
- Single active TCP connection maintained between peers
- Automatic connection failover and reconnection

### Agents
- agent1: Initiates conversation by dialing agent2 and sending a request
- agent2: Listens for connections from agent1, processes the request and
  sends a response using the same TCP connection established by agent1

## How It Works

1. Agents start with specified peer addresses and ports.
2. Agent1 dials agent2 and agent2 accepts the connection.
3. The kernel maintains one persistent TCP connection between the peers.
4. Message flow:
   - agent1 sends a "hello world" request every second via the outbound
     connection.
   - agent2 receives the request on the accepted TCP connection and sends a
     "hello back" response using the same connection.
   - agent1 receives the response on the connection it used to send the
     request.
   - Both agents print received messages to stdout.

## Running the Simulation

### Setup
1. In terminal 1 (agent1):
```bash
cd agent1
go run agent1.go -peer localhost:7272
```

2. In terminal 2 (agent2):
```bash
cd agent2
go run agent2.go -port 7272 
```

### Expected Output

**agent1:**
```
Agent1 running. Press enter to exit...
Agent1 received: hello back
```

**agent2:**
```
Agent2 running. Press enter to exit...
Agent2 received: hello world
```

## Notes

- Protocol CIDs are hardcoded for demonstration:
  - Request protocol: `bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny`
  - Response protocol:
    `bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu`
- The kernel automatically reconnects if the TCP connection drops.
- Press Enter in either terminal to gracefully shut down the agent.
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/README.md

File: /home/stevegt/lab/grid-poc/x/sim1/wire/wire.go
```go
package wire

import (
	"fmt"

	"github.com/fxamacker/cbor/v2"
	"github.com/ipfs/go-cid"
)

// Message represents a protocol message with protocol CID and payload.
type Message struct {
	Protocol []byte
	Payload  []byte
}

var (
	gridTagNum uint64 = 0x67726964 // 'grid' as 4-byte big-endian integer
	encOpts    cbor.EncOptions
	decOpts    cbor.DecOptions
	Em         cbor.EncMode
	Dm         cbor.DecMode
)

func init() {
	var err error
	// Use Core Deterministic Encoding for consistent serialization
	encOpts = cbor.CoreDetEncOptions()
	decOpts = cbor.DecOptions{}

	Em, err = encOpts.EncMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR enc mode: %v", err))
	}

	Dm, err = decOpts.DecMode()
	if err != nil {
		panic(fmt.Sprintf("failed to create CBOR dec mode: %v", err))
	}
}

// NewMessage creates a new CBOR-encoded message with protocol CID and payload
func NewMessage(cidV1 cid.Cid, payload []byte) ([]byte, error) {
	msg := Message{
		Protocol: cidV1.Bytes(),
		Payload:  payload,
	}
	return Em.Marshal(msg)
}

func (m Message) MarshalCBOR() ([]byte, error) {
	tag := cbor.Tag{
		Number:  gridTagNum,
		Content: []interface{}{m.Protocol, m.Payload},
	}
	return Em.Marshal(tag)
}

func (m *Message) UnmarshalCBOR(data []byte) error {
	var tag cbor.Tag
	if err := Dm.Unmarshal(data, &tag); err != nil {
		return err
	}

	if tag.Number != gridTagNum {
		return fmt.Errorf("invalid grid tag number: %d", tag.Number)
	}

	parts, ok := tag.Content.([]interface{})
	if !ok || len(parts) != 2 {
		return fmt.Errorf("invalid content format, expected 2-element array")
	}

	// Decode protocol CID
	switch v := parts[0].(type) {
	case []byte:
		m.Protocol = v
	case nil:
		m.Protocol = nil
	default:
		return fmt.Errorf("protocol field has unexpected type: %T", parts[0])
	}

	// Decode payload
	switch v := parts[1].(type) {
	case []byte:
		m.Payload = v
	case nil:
		m.Payload = nil
	default:
		return fmt.Errorf("payload field has unexpected type: %T", parts[1])
	}

	return nil
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/wire/wire.go

File: /home/stevegt/lab/grid-poc/x/sim1/kernel/kernel.go
```go
package kernel

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"
	"time"

	"sim1/wire"

	"github.com/ipfs/go-cid"
)

type Kernel struct {
	mu            sync.RWMutex
	subscriptions map[string]func(wire.Message)
	listener      net.Listener
	peerAddr      string
	conn          net.Conn
	connMu        sync.Mutex
	ctx           context.Context
	cancel        context.CancelFunc
}

func NewKernel() *Kernel {
	ctx, cancel := context.WithCancel(context.Background())
	return &Kernel{
		subscriptions: make(map[string]func(wire.Message)),
		ctx:           ctx,
		cancel:        cancel,
	}
}

func (k *Kernel) Start(port int) error {
	var err error
	k.listener, err = net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return fmt.Errorf("failed to listen: %v", err)
	}

	go k.acceptConnections()
	go k.maintainOutgoingConnection()
	return nil
}

func (k *Kernel) acceptConnections() {
	for {
		conn, err := k.listener.Accept()
		if err != nil {
			select {
			case <-k.ctx.Done():
				return
			default:
				log.Printf("accept error: %v", err)
			}
			continue
		}
		go k.handleConnection(conn)
	}
}

func (k *Kernel) maintainOutgoingConnection() {
	for {
		select {
		case <-k.ctx.Done():
			return
		default:
			if k.peerAddr == "" {
				time.Sleep(1 * time.Second)
				continue
			}

			k.connMu.Lock()
			if k.conn == nil {
				conn, err := net.Dial("tcp", k.peerAddr)
				if err != nil {
					log.Printf("dial error: %v", err)
					k.connMu.Unlock()
					time.Sleep(2 * time.Second)
					continue
				}
				k.conn = conn
				log.Printf("connected to peer %s", k.peerAddr)
				go k.handleConnection(conn)
			}
			k.connMu.Unlock()
			time.Sleep(5 * time.Second)
		}
	}
}

func (k *Kernel) handleConnection(conn net.Conn) {
	defer conn.Close()

	// Set this connection as active.
	k.connMu.Lock()
	if k.conn != nil {
		k.conn.Close()
	}
	k.conn = conn
	k.connMu.Unlock()

	for {
		var msg wire.Message
		dec := wire.Dm.NewDecoder(conn)
		err := dec.Decode(&msg)
		if err != nil {
			log.Printf("decode error: %v", err)
			return
		}

		protocolCid, err := cid.Cast(msg.Protocol)
		if err != nil {
			log.Printf("invalid protocol CID: %v", err)
			continue
		}

		k.mu.RLock()
		handler, exists := k.subscriptions[protocolCid.String()]
		k.mu.RUnlock()

		if exists {
			handler(msg)
		}
	}
}

func (k *Kernel) Publish(msg wire.Message) error {
	k.connMu.Lock()
	defer k.connMu.Unlock()

	if k.conn == nil {
		return fmt.Errorf("no active connection to peer")
	}

	enc := wire.Em.NewEncoder(k.conn)
	return enc.Encode(msg)
}

func (k *Kernel) Subscribe(protocol cid.Cid, handler func(wire.Message)) {
	k.mu.Lock()
	defer k.mu.Unlock()
	k.subscriptions[protocol.String()] = handler
}

func (k *Kernel) Unsubscribe(protocol cid.Cid) {
	k.mu.Lock()
	defer k.mu.Unlock()
	delete(k.subscriptions, protocol.String())
}

func (k *Kernel) SetPeer(addr string) {
	k.peerAddr = addr
}

func (k *Kernel) Stop() {
	k.cancel()
	k.connMu.Lock()
	if k.conn != nil {
		k.conn.Close()
	}
	k.connMu.Unlock()
	if k.listener != nil {
		k.listener.Close()
	}
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/kernel/kernel.go

File: /home/stevegt/lab/grid-poc/x/sim1/agent1/agent1.go
```go
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"time"

	"sim1/kernel"
	"sim1/wire"

	"github.com/ipfs/go-cid"
)

var (
	// Request protocol used to send messages to agent2.
	requestProtocolStr = "bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny"
	// Response protocol expected from agent2.
	responseProtocolStr = "bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu"
	peerAddr            = flag.String("peer", "localhost:7272", "peer address")
	listenPort          = flag.Int("port", 7271, "listen port")
)

func main() {
	flag.Parse()

	reqCid, err := cid.Decode(requestProtocolStr)
	if err != nil {
		log.Fatal("invalid request protocol CID:", err)
	}

	respCid, err := cid.Decode(responseProtocolStr)
	if err != nil {
		log.Fatal("invalid response protocol CID:", err)
	}

	k := kernel.NewKernel()
	k.SetPeer(*peerAddr)

	err = k.Start(*listenPort)
	if err != nil {
		log.Fatal("kernel start failed:", err)
	}
	defer k.Stop()

	// Subscribe to response protocol to receive replies on the same TCP
	// connection that was used to send the request.
	k.Subscribe(respCid, func(msg wire.Message) {
		fmt.Println("Agent1 received:", string(msg.Payload))
	})

	done := make(chan bool)

	go func() {
		// Send messages every second.
		payload := []byte("hello world")

		timer := time.NewTicker(1 * time.Second)
		for {
			select {
			case <-done:
				fmt.Println("Kernel stopped, exiting...")
				return
			case <-timer.C:
				err = k.Publish(wire.Message{
					Protocol: reqCid.Bytes(),
					Payload:  payload,
				})
				if err != nil {
					log.Fatal("publish failed:", err)
				}
			}
		}
	}()

	fmt.Fprintln(os.Stderr, "Agent1 running. Press enter to exit...")
	fmt.Scanln()
	done <- true
	time.Sleep(2 * time.Second) // Allow time for processing pending messages.
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/agent1/agent1.go

File: /home/stevegt/lab/grid-poc/x/sim1/agent2/agent2.go
```go
package main

import (
	"flag"
	"fmt"
	"log"
	"os"

	"sim1/kernel"
	"sim1/wire"

	"github.com/ipfs/go-cid"
)

var (
	// Request protocol expected on incoming messages from agent1.
	requestProtocolStr = "bafkreibm6jg3ux5qumhcn2b3flc3tyu6dmlb4xa7u5bf44ydelk6a2mhny"
	// Response protocol used to reply to agent1.
	responseProtocolStr = "bafkreieq5jui4j25l3wpyw54my6fzdtcssgxhtd7wvb5klqnbawtgta5iu"
	listenPort          = flag.Int("port", 7272, "listen port")
)

func main() {
	flag.Parse()

	reqCid, err := cid.Decode(requestProtocolStr)
	if err != nil {
		log.Fatal("invalid request protocol CID:", err)
	}

	respCid, err := cid.Decode(responseProtocolStr)
	if err != nil {
		log.Fatal("invalid response protocol CID:", err)
	}

	k := kernel.NewKernel()

	err = k.Start(*listenPort)
	if err != nil {
		log.Fatal("kernel start failed:", err)
	}
	defer k.Stop()

	// Subscribe to the request protocol. When a message is received from
	// agent1, send back a response using the same TCP connection.
	k.Subscribe(reqCid, func(msg wire.Message) {
		fmt.Println("Agent2 received:", string(msg.Payload))

		err := k.Publish(wire.Message{
			Protocol: respCid.Bytes(),
			Payload:  []byte("hello back"),
		})
		if err != nil {
			log.Print("response send failed:", err)
		}
	})

	fmt.Fprintln(os.Stderr, "Agent2 running. Press enter to exit...")
	fmt.Scanln()
}
```
EOF_/home/stevegt/lab/grid-poc/x/sim1/agent2/agent2.go