File: /home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md
```markdown
# Worldline Completion Model in Messaging Systems

The worldline completion model offers an innovative approach to managing events in a messaging system. It emphasizes creating, editing, and verifying a complete history of events for any given conversation or entity via a Merkle DAG structure. In this model, every message is a DAG edit operation—that is, a promise that the resulting worldline(s) are valid. This document reviews the pros and cons of this model, provides a design outline of a worldline data structure, and presents concrete examples with agents like Alice and Bob. It also discusses how operations (DAG edits, queries, and subscriptions) can be expressed as CWT claims, and concludes with a review of consistency and recommendations for terminology clarity.

---

## Overview of the Worldline Completion Model

In the worldline completion model, the following principles are observed:

- **Multiple Worldlines with Branch and Merge:**  
  The system supports multiple concurrent worldlines that may branch and merge. A single event can appear in multiple worldlines, reflecting various perspectives or states.

- **DAG-Based Organization of Events:**  
  Instead of using sequential event numbers, events are organized in a Merkle DAG. This has several implications:
  - **Leaf Nodes (Events):**  
    Each event (or leaf) is an immutable record that includes its payload (a set of PT-style promises expressed as CWT claims), a timestamp from the perspective of the creating agent, and a digital signature. Notably, leaves do not include a hash linking directly to a previous event.
  - **Internal Nodes:**  
    Internal nodes log the messages (or edit operations) that have modified the worldline. They store the hashes of their children in worldline order, thereby ensuring the integrity of the entire history. When an edit (insert, delete, or reorder) is performed on the DAG, the message includes the hashes of existing internal nodes as a guarantee of consistency.

- **Unified Editing, Query, and Subscription Language:**  
  A single language is used to express DAG edit operations, query requests, and subscription requests. Each operation is issued as a promise (via CWT claims) and is designed to be verifiable, ensuring that any alteration to the DAG maintains historical consistency.

- **Message and Event Terminology:**  
  To avoid ambiguity:
  - Use **"event"** exclusively when referring to the immutable record stored in the Merkle DAG.
  - Use **"message"** when referring to the DAG edit (or query/subscription) operation that carries the promise to effect a change or to retrieve data.

- **Replayability:**  
  Since every edit is a cryptographically verifiable promise and the entire history is logged, it is possible to replay the changes from any point in time. This replay ability is fundamental for state reconstruction, especially in distributed systems where agents may be temporarily offline.

- **CWT Claims as Promises:**  
  Every DAG operation—whether an edit, a query, or a subscription—is expressed as a CWT claim. This ensures that the operation is a promise rather than a request, meaning that it asserts the existence of an event or the validity of an operation.

---

## Worldline Data Structure

A conceptual Go-style structure for a worldline event might be defined as follows:

```go
type WorldlineEvent struct {
    Timestamp time.Time // Timestamp from the creating agent's perspective.
    Agent     string    // Creator's identifier, e.g., "Alice" or "Bob".
    Payload   []byte    // A set of PT-style promises expressed as CWT claims.
    // Additional metadata and signature can be included as needed.
}
```

**Merkle DAG Essentials:**

- **Editable History Without Direct Prev-Links in Leaves:**  
  The integrity of the event history is maintained by internal nodes; leaves are purposefully kept free from direct hash links to prior events.

- **DAG Node as an Edit Log:**  
  Each internal node is a log that records all messages (edit operations) affecting that segment of the worldline. This guarantees that any change—whether it is an insertion, deletion, or reordering—is verifiable using the stored child hashes.

---

## Example Scenarios

### 1. DAG Edit Message Example

An agent, such as Alice, can perform an edit operation to insert a new event into a specific worldline. The corresponding message includes the hashes of the relevant internal nodes (ensuring the operation is applied over a known state) and is expressed as a promise via CWT claims.

**Example JSON Representation:**

```json
{
  "op": "insert",
  "agent": "Alice",
  "timestamp": "2023-10-01T10:05:00Z",
  "target": "worldline123",
  "payload": {
    "claims": [
      {"promise": "Insert event 'Hello' into the worldline", "detail": "Initial greeting"}
    ]
  },
  "prevHashes": ["hash_internalNode1", "hash_internalNode2"],
  "signature": "abc123signature"
}
```

In this message, Alice promises that the event "Hello" is inserted into `worldline123` and provides the previous Merkle DAG internal node hashes to validate the edit operation.

---

### 2. DAG Query Message Example

An agent, such as Bob, can query a worldline to retrieve events based on certain criteria. Although a query might traditionally be viewed as a request, here it is framed as a promise asserting that certain events exist.

**Example JSON Representation:**

```json
{
  "op": "query",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:10:00Z",
  "target": "worldline123",
  "criteria": {
    "since": "2023-10-01T10:00:00Z"
  },
  "claims": [
    {"promise": "Retrieve all events after the specified timestamp"}
  ],
  "signature": "bobSignatureXYZ"
}
```

Bob’s message is a promise to retrieve all events from `worldline123` that have been recorded after `2023-10-01T10:00:00Z`.

---

### 3. DAG Subscription Message Example

An agent can subscribe to updates on a worldline to receive real-time notifications as the DAG is modified. The subscription is expressed as a promise, indicating that the subscribing agent will be notified of subsequent changes matching specific criteria.

**Example JSON Representation:**

```json
{
  "op": "subscribe",
  "agent": "Bob",
  "timestamp": "2023-10-01T10:15:00Z",
  "target": "worldline123",
  "criteria": {
    "filter": "insert"
  },
  "claims": [
    {"promise": "Subscribe to insertion events in the worldline"}
  ],
  "signature": "bobSubsSignature456"
}
```

In this example, Bob promises that he will receive notifications for any insertion events on `worldline123`.

---

## Consistency and Final Review

- **Multiple Worldlines and Branching:**  
  The model inherently supports multiple worldlines with capabilities for branch and merge operations. A single message may simultaneously edit more than one worldline, ensuring comprehensive state modifications.

- **Promise-Based Communication:**  
  All messages (whether they perform edits, queries, or subscriptions) are structured as promises expressed via CWT claims. This uniform approach reinforces the cryptographic and contractual integrity of every operation.

- **Terminology Clarification:**  
  The term **"event"** now strictly refers to the immutable record in the Merkle DAG, while **"message"** refers to the DAG edit or operation that carries the promise. This differentiation is critical to avoid confusion in the documentation and implementation.

- **Reproducibility and Replayability:**  
  By storing every message (edit operation) along with the hashes of the old internal nodes, the system guarantees replayability. This allows the complete re-creation of any worldline state at any point in time, essential for debugging, recovery, and audit purposes.

- **CWT Claims as Low-Level Promises:**  
  The editing, query, and subscription operations are all expressed as CWT claims, ensuring that low-level claims remain promises rather than mere requests. This guarantees that every operation comes with cryptographic assurances (via digital signatures) and a verifiable state transition.

- **No Redundant Hash Data in Leaves:**  
  Maintaining minimal data in event leaves (which do not include previous event hashes) reduces redundancy; all historical linkages are managed by internal nodes, analogous to the structure seen in a Git repository.

---

## Conclusion

The worldline completion model leverages a Merkle DAG to provide a reliable, verifiable, and replayable history of events. By expressing all operations as promises through CWT claims and maintaining a clear distinction between immutable events and operational messages, the system ensures robustness, consistency, and transparency. Agents such as Alice and Bob can confidently perform edits, queries, and subscriptions, with every change cryptographically secured and historically consistent. This model not only supports complex operations like branching, merging, and multiple worldline edits but also facilitates easy state reconstruction and verification.
```
EOF_/home/stevegt/lab/grid-poc/x/dispatcher/worldlines.md