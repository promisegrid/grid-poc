Below is one way to write main.go using GopherJS (i.e. using Go’s js package, which is supported by GopherJS) that does what main.js did in JavaScript. In this example the Go code creates a new instance of Go (defined in wasm_exec.js), then fetches and instantiates the hello.wasm module—using instantiateStreaming if available—and finally runs the Go WASM module by calling go.run(instance). (Remember that you still must build hello.go as WASM and copy wasm_exec.js in the proper location.) 

For example, you might add this new file alongside hello.go:

------------------------------------------------------------
File: main.go
------------------------------------------------------------
package main

import (
	"syscall/js"
)

func main() {
	// Create a new instance of Go by calling the Go constructor defined in wasm_exec.js.
	goInstance := js.Global().Get("Go").New()

	wasm := js.Global().Get("WebAssembly")
	fetchWasm := js.Global().Get("fetch").Invoke("hello.wasm")

	// We need to branch based on whether instantiateStreaming is available.
	if wasm.Get("instantiateStreaming").Truthy() {
		// If supported, use instantiateStreaming.
		thenFetch := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
			// args[0] is the Response object.
			instPromise := wasm.Call("instantiateStreaming", args[0], goInstance.Get("importObject"))

			thenInst := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
				// Once the instantiation is complete, call goInstance.run with the instance.
				goInstance.Call("run", args[0].Get("instance"))
				// Optionally release the function once used.
				thenInst.Release()
				return nil
			})
			instPromise.Call("then", thenInst)
			// Optionally release the fetch callback here.
			thenFetch.Release()
			return nil
		})
		fetchWasm.Call("then", thenFetch)
	} else {
		// Fallback path for browsers that do not support instantiateStreaming.
		thenFetch := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
			response := args[0]
			arrayBufPromise := response.Call("arrayBuffer")
			thenArray := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
				bytes := args[0]
				instPromise := wasm.Call("instantiate", bytes, goInstance.Get("importObject"))
				thenInst := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
					goInstance.Call("run", args[0].Get("instance"))
					thenInst.Release()
					return nil
				})
				instPromise.Call("then", thenInst)
				thenArray.Release()
				return nil
			})
			arrayBufPromise.Call("then", thenArray)
			thenFetch.Release()
			return nil
		})
		fetchWasm.Call("then", thenFetch)
	}

	// Prevent the GopherJS program from exiting.
	select {}
}

------------------------------------------------------------

How this works:

1. The code fetches "hello.wasm" using the JavaScript fetch API via js.Global().Get("fetch") (wrapped in js package calls).

2. It checks whether WebAssembly.instantiateStreaming is available by testing if wasm.Get("instantiateStreaming") is truthy.

3. If available, it uses instantiateStreaming to directly compile the WASM module from the Response; otherwise it falls back to fetching the ArrayBuffer and then calling WebAssembly.instantiate.

4. Once the instantiation promise resolves, it calls goInstance.run(instance) to run the WASM module (just like main.js did).

5. The call to select {} at the end keeps the main() function running indefinitely.

To compile this file to JavaScript using GopherJS, run (assuming GopherJS is installed):

   gopherjs build -o main.js main.go

Then your project will consist of:

 • hello.go (compiled to hello.wasm)
 • wasm_exec.js (copied from $GOROOT/misc/wasm/wasm_exec.js)
 • hello.html (loads wasm_exec.js and main.js)
 • main.js (compiled from main.go via GopherJS)
 • Makefile (which you might update to invoke gopherjs build on main.go)

Happy coding with Go, GopherJS, and WebAssembly!