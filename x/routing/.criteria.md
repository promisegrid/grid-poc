# PromiseGrid Message and Routing Proposals Fitness Criteria

We want to improve upon the original PromiseGrid message format
proposal, which looks something like this:

type Message struct {
  Tag    struct {
    Number uint64 // = 0x67726964 = 'grid' as 4-byte big-endian integer
    Content struct {
      Protocol []byte  // CID referring to a particular protocol or mach-like port
      Payload  []byte  // Message payload -- signature in payload per spec document
    }
}

This pushes most routing, filtering, and signature verification
operations into the agents; agents subscribe to port numbers.  All the
PromiseGrid kernel needs to do is to route the message to the correct
agent.  We're not sure this is the right approach, and we want to
explore alternatives.

Here are some of the criteria we will use to score alternatives,
each preceeded by a points weight:

- 200 Router can be written in a few hundred lines of code
- 200 Message format provides a means for the kernel to choose among
  multiple conflicting agents.
- 150 Message format is simple and extensible 
- 150 Message headers contain only enough information to route the
  message to the correct agent
- 100 Proposal shows a Go struct for the message format
- 100 Proposal shows pseudocode for the algorithm used to route a
  message to an agent
- 100 Proposal shows the host functions that the PromiseGrid kernel
  needs to support for agents running in WASM runtimes
- 95 Decentralized architecture enabling user-owned nodes and organic
  network growth without centralized control
- 90 simple-enough routing that can be implemented by a tiny
  promisegrid kernel on an IoT device
- 90 Capability-based security model implementing fine-grained access
  control through cryptographic promises and tokens
- 85 Content-addressable code storage using multihash format for
  immutable, platform-agnostic execution environments
- 80 Message contains a signature from the promising agent (the author)
- 80 Merge-as-consensus conflict resolution mechanism enabling
  application-specific document merging strategies
- 75 Cross-platform compatibility supporting execution from IoT to browser
  tabs to bare-metal servers via multiple sandbox technologies
- 70 Computational governance exposing consensus mechanisms as system
  calls for organizational decision-making
- 65 Decentralized cache implementation with referentially transparent
  function response storage and replication
- 60 Integration with prior technologies including WASM, container
  orchestration, and infrastructure-as-code principles
- 60 Universal protocol design allowing nested message passing and
  hyperkernel routing extensibility
- 55 Community-driven development model with open participation in
  protocol evolution and tooling creation
- 30 bid/ask semantics at the network layer for
  routing and resource allocation 
