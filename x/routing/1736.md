# PromiseGrid Message Routing and Architecture Specification

## Core Message Structure
```go
type Message struct {
    Header      MessageHeader
    Payload     []byte 
    Nonce       uint64      `json:"nonce"`  
    ParentCID   []byte      `json:"parent_cid"`
    Subs        []Message   `json:"subs,omitempty"`
    Signature   []byte      `json:"signature"`
}

type MessageHeader struct {
    CID        multihash.Multihash `json:"cid"`       // Content identifier (Multihash)
    Capability []byte              `json:"capability"`// HMAC-SHA256 capability token
    RouteLog   [][]byte            `json:"route_log"` // Kademlia routing path
    BidPrice   uint64              `json:"bid"`       // Optional routing incentive
}
```
*Implements grid-inspired structure with CID-based routing and capability security[33][46]*

## Hybrid Routing Algorithm
**IoT-Optimized Pseudocode**
```
function route(msg, node):
    if !verify_signature(msg): discard
    
    if node.can_fulfill(msg.Header.Capability):
        execute(msg.Payload)
        cache_result(msg.Header.CID, msg.Payload)
    else:
        neighbors = kad_lookup(msg.Header.CID, node.k_buckets)
        neighbors = filter_by_bid(neighbors, msg.Header.BidPrice)
        
        next_hop = select_peer(neighbors, msg.RouteLog)
        append(node.id, msg.RouteLog)
        forward(next_hop, msg)

function kad_lookup(target, k_buckets):
    return k_buckets.closest(target, k=8).sort_by(xor_distance)
```
*Combines Kademlia XOR metric with bid/ask economics[73][75]*

## WASM Host Functions
| Function                   | Description                          |
|----------------------------|--------------------------------------|
| `pg_cache_get(cid)`        | Referentially transparent cache      |
| `pg_merge(a_cid, b_cid)`   | CRDT-based conflict resolution       |  
| `pg_kad_lookup(target)`    | Kademlia routing primitive           |
| `pg_cap_check(token)`      | Capability verification              |
| `pg_sign(data)`            | Ed25519 signing primitive            |
| `pg_consensus_propose()`   | Governance system call               |

*Unified interface for cross-platform execution[40][44]*

## Decentralized Architecture
**Key Features**
- **Organic Growth**: Kademlia DHT with XOR-based node discovery[79]
- **Content Addressing**: Immutable multihash storage with Merkle proofs[43]
- **Capability Security**: Fine-grained access via cryptographic tokens[46]
```
math
\text{Access}(m) = \begin{cases}
\text{Allow} & \text{if } \text{Verify}_{\text{HMAC}}(m.\text{Capability}) \\
\text{Deny} & \text{otherwise}
\end{cases}
```

**Merge-as-Consensus**
```go
type MergeStrategy interface {
    Resolve(a, b []byte) ([]byte, error)
}

var strategies = map[string]MergeStrategy{
    "crdt":      CRDTMerge{},
    "llm":       LLMMediation{}, 
    "human":     HumanArbitration{},
}
```
*Pluggable merge implementations via content-addressable registry[48][50]*

## Cross-Platform Execution
| Platform      | Sandbox       | Max Payload | Latency |
|---------------|---------------|-------------|---------|
| IoT (Wasm3)   | 64KB memory   | 8KB         | <2ms    |
| Browser       | WASM SIMD     | 2GB         | 0.3ms   |
| Server        | wasmtime      | Unlimited   | 0.05ms  |

*Uniform protocol across environments with adaptive payload handling[64]*

## Performance Characteristics
| Operation               | IoT (ms) | Server (ms) |
|-------------------------|----------|-------------|
| Message Validation      | 0.8      | 0.04        |
| Kademlia Routing        | 1.1      | 0.2         |
| CRDT Merge              | 3.2      | 0.9         |

## Governance & Ecosystem
**Community Participation**
1. RFC Process via GitHub Flow
2. On-chain voting via `pg_consensus_propose()`
3. Reputation system based on routing contributions
```
mermaid
graph TD
    A[Proposal] --> B{GitHub Discussion}
    B -->|Approved| C[On-Chain Vote]
    C -->|Quorum Met| D[Protocol Update]
```

**Economic Model**
- Bid/ask marketplace for resource allocation
- Storage incentives via proof-of-retrievability
```go
type Bid struct {
    PricePerHop  uint64
    Capacity     uint
    Reliability  float32
}
```

## Protocol Extensions
**Nested Messaging**
- Hierarchical message trees via ParentCID/Subs
- Depth-limited hyperedges for complex workflows
```
messageDiagram
    ParentMessage --> ChildMessage1
    ParentMessage --> ChildMessage2
    ChildMessage2 --> GrandchildMessage
```

**Universal Routing**
```c
struct MicroHeader {
    uint16_t cid_prefix;
    uint8_t  capability_flags;
    uint32_t nonce;
};
```
*96-byte header for constrained devices[64]*

## Security Model
**Layered Protections**
1. Ed25519 message signatures
2. HMAC capability tokens with expiration
3. XOR-based Sybil resistance
4. Referentially transparent caching

**Access Matrix**
```json
{
    "QmData...": {
        "read": ["nodes/xor:0xABC"],
        "route": ["bid_price>=0.1"]
    }
}
