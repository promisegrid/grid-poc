- 6000 Answers the question "If a match is found, K_Bob_ does what?"  The problem is that we would need some sort of coordination or locking mechanism to ensure that the two kernels agree to the match, and that they both update their ledgers and release escrow accordingly.  This is a basic computer science problem.
- 5000 Answers the question "How does inter-node communication work?"
- 5000 Answers the question "How do agents communicate with each other, and how do they build trust?"
- 5000 Answers the question "Do agents know each other, or do they only know the kernel?"
- 4000 Matching engine algorithm is simple and clear
- 3000 discusses similarity with Mach kernel's message-passing model
- 2000 Every message is a function call asking the kernel to do something
- 2000 Get rid of "kernel-mediated channels" language -- it's just a message-passing system
- 2000 Kernel buys low and sells high to regulate resource allocation by regulating order flow between agents
- 1000 File is internally consistent in logic and terminology, avoiding contradictions
- 1000 Considers the kernel to be a trusted third party
- 1000 Considers the kernel to be the counterparty for all trades
- 1000 Kernel starts agents
- 1000 Agents are clients of the kernel -- kernel is a server
- 1000 Answers the question "Do agents only talk to the kernel?" 
- 1000 Answers the question "Does the kernel handle all network communication?" 
- 1000 Answers the question "Do messages between agent and local kernel need to be signed?  What about messages over the network?  Who signs them?" 
- 1000 Uses double-entry accounting to track personal currencies
- 1000 Considers promise make/break accounting record to be equivalent to personal currencies 
- 1000 Messages are stored in a hypergraph structure
- 1000 A message is a balanced double-entry accounting transaction
- 1000 A message is a conditional promise
- 900 Describes the CBOR message format.
- 200 Prefers discussion in paragraph form, explains reasoning, ensuring a narrative flow that enhances understanding
- 190 wraps lines at 70 characters: maintains readability and consistency with formatting standards
- 100 Correctly applies Promise Theory's core tenets: distinguishes requests as impositions (attempts to influence others) from promises as voluntary commitments about one's own future behavior
- 95 analyzes how BID-type requests contain embedded promises (e.g., compensation offers become promissory commitments) while maintaining request/promise distinction
- 90 never frames requests as binding obligations, preserving agents' freedom to accept/reject requests without commitment
- 85 details specific conditions where requests morph into promises (e.g., compensation acceptance creates collateralized commitments)
- 80 Incorporates assessment mechanisms: specifies how promise-tracking applies to request-embedded commitments (e.g., compensation promise fulfillment status)
- 75 Distinguishes directionality: shows requests initiate negotiation (bidirectional) vs. promises establish unilateral commitments
- 70 Uses Burgess' "voluntary cooperation" framework: positions requests as influence attempts and promises as self-commitments
- 65 Addresses economic dimensions: analyzes compensation offers as value-transfer promises within request structures
- 60 Contrasts failure consequences: differentiates reputation impacts of broken promises vs. rejected/unfulfilled requests
