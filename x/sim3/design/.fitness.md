- 9000 Execution contexts: embedded (kernel) vs independent peers
- 8500 Distinguishes kernel-embedded agents (simple) from independent agents (complex) 
- 8000 Prefers discussion in paragraph form, not bullet points. 
- 8000 Explains reasoning, ensuring a narrative flow that enhances understanding
- 7000 wraps lines at 70 characters: maintains readability and consistency with formatting standards
- 5000 Considers ASK order hashes to be like listen() socket addresses, and BID orders to be like connect() socket calls
- 4500 Considers ASK order hashes to be like Mach-style port numbers, and BID orders to be like messages sent to those ports
- 4000 Discusses the items in the "Other Considerations and Clarifications" section below
- 4000 Answers the question "How does inter-node communication work?"
- 4000 Answers the question "How do agents communicate with each other, and how do they build trust?"
- 4000 Answers the question "Do agents know each other, or do they only know the kernel?"
- 4000 Answers the question "If a match is found, K_Bob_ does what?"  The problem is that we would need some sort of coordination or locking mechanism to ensure that the two kernels agree to the match, and that they both update their ledgers and release escrow accordingly.  This is a basic computer science problem.
- 4000 Matching engine algorithm is simple and clear
- 3000 discusses similarity with Mach kernel's message-passing model
- 2000 Every message is a function call asking the kernel to do something
- 2000 Kernel buys low and sells high to regulate resource allocation by regulating order flow between agents
- 1000 File is internally consistent in logic and terminology, avoiding contradictions
- 1000 Considers the kernel to be a trusted third party
- 1000 Considers the kernel to be the counterparty for all trades
- 1000 Kernel starts agents
- 1000 Agents are clients of the kernel -- kernel is a server
- 1000 Answers the question "Do agents only talk to the kernel?" 
- 1000 Answers the question "Does the kernel handle all network communication?" 
- 1000 Answers the question "Do messages between agent and local kernel need to be signed?  What about messages over the network?  Who signs them?" 
- 1000 Uses double-entry accounting to track personal currencies
- 1000 Considers promise make/break accounting record to be equivalent to personal currencies 
- 1000 Messages are stored in a hypergraph structure
- 1000 A message is a balanced double-entry accounting transaction
- 1000 A message is a conditional promise
- 900 Describes the CBOR message format.
- 100 Correctly applies Promise Theory's core tenets: distinguishes requests as impositions (attempts to influence others) from promises as voluntary commitments about one's future behavior
- 95 analyzes how BID-type requests contain embedded promises (e.g., compensation offers become promissory commitments) while maintaining request/promise distinction
- 90 never frames requests as binding obligations, preserving agents' freedom to accept/reject requests without commitment
- 85 details specific conditions where requests morph into promises (e.g., compensation acceptance creates collateralized commitments)
- 80 Incorporates assessment mechanisms: specifies how promise-tracking applies to request-embedded commitments (e.g., compensation promise fulfillment status)
- 75 Distinguishes directionality: shows requests initiate negotiation (bidirectional) vs. promises establish unilateral commitments
- 70 Uses Burgess' "voluntary cooperation" framework: positions requests as influence attempts and promises as self-commitments

Other considerations and clarifications:

We need to figure out how agents communicate with each other, and how
trust is built over time in a community. 

The kernel provides a **message passing** interface that allows
agents to send and receive messages through the kernel, ensuring that
all communication is logged and tamper-evident. 

Personal currencies represent the **unit of account** for
promises, with each agent maintaining a ledger of their transactions
with the kernel and other agents.  An agent can use the history of
other agents' promise keep/break behavior to in turn buy or sell the
other agent's currency, influencing the relative exchange rate.  The
resulting exchange rate reflects the community's trust in an agent's
promise-keeping behavior, with higher trust leading to a stronger
currency.

There needs to be a matching engine somewhere that matches
bid and ask orders.  A bid order is a promise to owe a certain amount
of the other agent's currency, while an ask order is a promise to
perform a service in exchange for a certain amount of the
agent's own currency.  

# Local Communication and Matching

When Alice wants to perform a service for Bob, she can create an
**ask order** that specifies the service she is willing to perform and
the amount of her personal currency she requires in exchange. Bob can
then create a **bid order** that specifies the service he wants and the
amount of Alice's personal currency he is willing to pay.  The matching
engine matches these orders based on the specified service and
currency amounts, ensuring that both parties agree on the terms of the
transaction, acting as escrow for the exchange of promises.

For example:

- Alice asks for 20 ALICE points in exchange for performing service S.
- Bob bids 20 ALICE points to receive service S.
- The matching engine matches Bob's bid with Alice's ask, invoking Alice's
  promise to perform service S for Bob in exchange for 20 ALICE points.
- Alice performs service S, sends the result to the kernel, the kernel
  updates Alice's and Bob's ledgers accordingly, and sends the result
  to Bob.   (Is the matching engine part of the kernel, or a separate
  service?)

# Communication Across Machines

Okay, that all works locally, but what about when Alice and Bob are
not on the same machine?  

## Option A:

The kernel provides a **network interface** that allows agents to
communicate with each other across machines. 

When Alice wants to send a message to Bob, she sends it to the kernel,
which then forwards it to Bob's kernel instance. The kernels in some
way cooperate to discover and 

## Option B:

The kernel provides a **distributed ledger** that allows agents to
communicate with each other across machines.  This distributed ledger
is a hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

When Alice wants to send a message to Bob, she creates a transaction
that specifies the message and sends it to the kernel. The kernel
then broadcasts the transaction to all other kernels in the network,
which then forward it to Bob's kernel instance. The kernels in some
way cooperate to ensure that the message is delivered to Bob's kernel
instance, and that Bob's kernel instance updates its ledger accordingly.

## Option C:

The kernel provides a **decentralized open market** that allows agents to
communicate with each other across machines. This open market is a
hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

For example:

- Alice create an ASK order to perform service S for 20 ALICE points.
- Alice sends the ASK order to her local kernel K_Alice_.
- K_Alice_ forwards the ASK order to all known peers.
- K_Bob_ receives the ASK order and checks if it matches any of Bob's
  existing BID orders.
- If a match is found, K_Bob_ does what?  The problem here is that we
  would need some sort of coordination or locking mechanism to ensure
  that the two kernels agree to the match, and that they both update
  their ledgers and release escrow accordingly.  This is a
  basic computer science problem.



# Brainstorming

Hashes give us a way of uniquely identifying Mach-style port numbers
across machines.  Is there something we can do with this insight that
will ease the problem of matching orders across machines?  Can we use
the hash of the ASK order to identify the order across machines, and
then use that hash to match it with a BID order on another machine?
Obviously if this were to work, all of the attributes of the ASK and
BID orders would need to be identical, so that the hash would match.

What else can we do with this insight?  

For example, if we think of the entire universe as one big address
space, and if the hashes are the addresses, then we can think of the
BID and ASK orders as being like Mach-style ports, where the ASK order
is like a port that is waiting for a message, and the BID order is
like a message that is being sent to that port.  The matching engine
could then be thought of as a message-passing system that matches
BID and ASK orders based on their hashes, ensuring that the
messages are delivered to the correct ports.  This would allow us to
match orders across machines without needing to coordinate or lock
the kernels, as the hashes would ensure that the orders are unique and
that the messages are delivered to the correct ports.

Insight:  A bid is specific, with particular attributes (function
arguments).  An ask is general, typically naming a function to be
performed, and perhaps some argument limits (though the function
itself might encode those limits, which means the limits would
influence the hash).  In other words, an ASK order is like a
function signature, while a BID order is like a function call with
specific arguments.  The matching engine can then match BID orders
with ASK orders based on the function signature and the specific
arguments, ensuring that the messages are delivered to the correct
ports.  This would allow us to treat ASK orders as ports.

Is it possible that we're talking about a two-layer system here?
- one layer is the local kernel that handles local communication and
  matching, and provides a message-passing interface for agents to
  communicate with each other.
- the other layer is a distributed ledger or open market that allows
  agents to communicate with each other across machines, ensuring that
  all communication is logged and tamper-evident.

Or is it all ASK ports, i.e. all an agent eer knows is that it is
either publishing an ASK order (which creates a port) or sending a
BID order (which is a message sent to an ASK port)?  In this case, the
matching engine would be responsible for matching BID orders with ASK
ports, and ensuring that the messages are delivered to the correct ports.

Is it possible that the kernel maintains some sort of "plugboard" of
remote ASK ports?  How does the kernel know about remote ASK ports?

How does the kernel handle the case where a BID does not match any
known ASK port?  Does it create a new ASK port for the BID search,
then send search bids to all known peers, asking them to match the
BID with any ASK ports they know about?  

Are we perhaps leading toward a design where the matching is
always done by whichever kernel is hosting an ASK port, and the
BID orders are sent to that kernel?  If so, this is roughly equivalent
to the socket listen() model, where the ASK port is like a socket
listening for connections, and the BID order is like a connection
request sent to that socket.  The matching engine would then be
responsible for matching BID orders with ASK ports based on the
function signature and the specific arguments, ensuring that the
messages are delivered to the correct ports.







## Execution Contexts

The system distinguishes two execution contexts affecting trusted third
parties and use of force:

1. **Agent Embedded in Trusted Kernel (Trent)**:  
   - Alice runs within Trent's execution context (kernel/interpreter)  
   - Trent is able to exert use of force over Alice's execution  
   - Alice must trust Trent  
   - Trent serves as matching engine for Alice's orders  
   - Alice can be simple agent: No order book, accounting, or matching engine  
   - Example: Kernel-embedded agents in PromiseGrid nodes  

2. **Independent Execution Contexts (Trent/Tina)**:  
   - Agents run in isolated environments  
   - No ability to exert use of force over each other  
   - Matching engine options:  
     a) Match orders on agent holding ASK (decentralized)  
     b) Use third-party matching engine (Tom)  
     c) Implement decentralized matching algorithm  
   - Agents are complex: Maintain order books, accounting, matching engines  
   - Example: Cross-node agent interactions  

## Communication Protocols

The kernel provides a **message passing** interface that allows agents to 
send and receive messages exclusively through kernel mediation. This 
ensures all communication is logged and tamper-evident while abstracting 
network details. Personal currencies represent the **unit of account** for 
promises, with each agent maintaining a ledger of transactions. Agent 
promise history builds trust, influencing currency exchange rates that 
reflect community confidence in promise-keeping capability.

## Matching Engine Implementation

### Local Matching
- ASK orders specify service and required currency compensation  
- BID orders specify desired service and offered compensation  
- Kernel matches compatible orders using price-time priority  
- Transaction execution:  
  1. Escrow activation (compensation reserve)  
  2. Service execution verification  
  3. Ledger update and result delivery  

### Distributed Matching
Cross-machine transactions use two-phase commit protocol:  
1. **Prepare Phase**: Resource verification across kernels  
2. **Commit Phase**: Atomic ledger update  
ASK orders publish as content-addressed hashes (Mach-style ports) while 
BID orders target these hashes across nodes. Successful matches record 
as hypergraph edges.

## Kernel Security Functions
- **Local Messages**: Agent-signed with private key  
- **Network Messages**: Kernel-resigned for transit  
- **Ledger Entries**: Kernel-signed for non-repudiation  
Verification includes SHA-3 digest, sender private key encryption, and 
recipient public key decryption.

