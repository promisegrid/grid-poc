We need to figure out how agents communicate with each other, and how
trust is built over time in a community. 

The kernel provides a **message passing** interface that allows
agents to send and receive messages through the kernel, ensuring that
all communication is logged and tamper-evident. 

Personal currencies represent the **unit of account** for
promises, with each agent maintaining a ledger of their transactions
with the kernel and other agents.  An agent can use the history of
other agents' promise keep/break behavior to in turn buy or sell the
other agent's currency, influencing the relative exchange rate.  The
resulting exchange rate reflects the community's trust in an agent's
promise-keeping behavior, with higher trust leading to a stronger
currency.

There needs to be a matching engine somewhere that matches
bid and ask orders.  A bid order is a promise to owe a certain amount
of the other agent's currency, while an ask order is a promise to
perform a service in exchange for a certain amount of the
agent's own currency.  

# Local Communication and Matching

When Alice wants to perform a service for Bob, she can create an
**ask order** that specifies the service she is willing to perform and
the amount of her personal currency she requires in exchange. Bob can
then create a **bid order** that specifies the service he wants and the
amount of Alice's personal currency he is willing to pay.  The matching
engine matches these orders based on the specified service and
currency amounts, ensuring that both parties agree on the terms of the
transaction, acting as escrow for the exchange of promises.

For example:

- Alice asks for 20 ALICE points in exchange for performing service S.
- Bob bids 20 ALICE points to receive service S.
- The matching engine matches Bob's bid with Alice's ask, invoking Alice's
  promise to perform service S for Bob in exchange for 20 ALICE points.
- Alice performs service S, sends the result to the kernel, the kernel
  updates Alice's and Bob's ledgers accordingly, and sends the result
  to Bob.   (Is the matching engine part of the kernel, or a separate
  service?)

# Communication Across Machines

Okay, that all works locally, but what about when Alice and Bob are
not on the same machine?  

## Option A:

The kernel provides a **network interface** that allows agents to
communicate with each other across machines. 

When Alice wants to send a message to Bob, she sends it to the kernel,
which then forwards it to Bob's kernel instance. The kernels in some
way cooperate to discover and 

## Option B:

The kernel provides a **distributed ledger** that allows agents to
communicate with each other across machines.  This distributed ledger
is a hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

When Alice wants to send a message to Bob, she creates a transaction
that specifies the message and sends it to the kernel. The kernel
then broadcasts the transaction to all other kernels in the network,
which then forward it to Bob's kernel instance. The kernels in some
way cooperate to ensure that the message is delivered to Bob's kernel
instance, and that Bob's kernel instance updates its ledger accordingly.

## Option C:

The kernel provides a **decentralized open market** that allows agents to
communicate with each other across machines. This open market is a
hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

For example:

- Alice create an ASK order to perform service S for 20 ALICE points.
- Alice sends the ASK order to her local kernel K_Alice_.
- K_Alice_ forwards the ASK order to all known peers.
- K_Bob_ receives the ASK order and checks if it matches any of Bob's
  existing BID orders.
- If a match is found, K_Bob_ does what?  The problem here is that we
  would need some sort of coordination or locking mechanism to ensure
  that the two kernels agree to the match, and that they both update
  their ledgers and release escrow accordingly.  This is a
  basic computer science problem.



# Brainstorming

Hashes give us a way of uniquely identifying Mach-style port numbers
across machines.  Is there something we can do with this insight that
will ease the problem of matching orders across machines?  Can we use
the hash of the ASK order to identify the order across machines, and
then use that hash to match it with a BID order on another machine?
Obviously if this were to work, all of the attributes of the ASK and
BID orders would need to be identical, so that the hash would match.

What else can we do with this insight?  

For example, if we think of the entire universe as one big address
space, and if the hashes are the addresses, then we can think of the
BID and ASK orders as being like Mach-style ports, where the ASK order
is like a port that is waiting for a message, and the BID order is
like a message that is being sent to that port.  The matching engine
could then be thought of as a message-passing system that matches
BID and ASK orders based on their hashes, ensuring that the
messages are delivered to the correct ports.  This would allow us to
match orders across machines without needing to coordinate or lock
the kernels, as the hashes would ensure that the orders are unique and
that the messages are delivered to the correct ports.

Insight:  A bid is specific, with particular attributes (function
argumnets).  An ask is general, typically naming a function to be
performed, and perhaps some argument limits (though the function
itself might encode those limits, which means the limits would
influence the hash).  In other words, an ASK order is like a
function signature, while a BID order is like a function call with
specific arguments.  The matching engine can then match BID orders
with ASK orders based on the function signature and the specific
arguments, ensuring that the messages are delivered to the correct
ports.  This would allow us to treat ASK orders as ports.





