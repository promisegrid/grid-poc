We need to figure out how agents communicate with each other, and how
trust is built over time in a community. 

The kernel provides a **message passing** interface that allows
agents to send and receive messages through the kernel, ensuring that
all communication is logged and tamper-evident. 

Personal currencies represent the **unit of account** for
promises, with each agent maintaining a ledger of their transactions
with the kernel and other agents.  An agent can use the history of
other agents' promise keep/break behavior to in turn buy or sell the
other agent's currency, influencing the relative exchange rate.  The
resulting exchange rate reflects the community's trust in an agent's
promise-keeping behavior, with higher trust leading to a stronger
currency.

There needs to be a matching engine somewhere that matches
bid and ask orders.  A bid order is a promise to owe a certain amount
of the other agent's currency, while an ask order is a promise to
perform a service in exchange for a certain amount of the
agent's own currency.  

# Local Communication and Matching

When Alice wants to perform a service for Bob, she can create an
**ask order** that specifies the service she is willing to perform and
the amount of her personal currency she requires in exchange. Bob can
then create a **bid order** that specifies the service he wants and the
amount of Alice's personal currency he is willing to pay.  The matching
engine matches these orders based on the specified service and
currency amounts, ensuring that both parties agree on the terms of the
transaction, acting as escrow for the exchange of promises.

For example:

- Alice asks for 20 ALICE points in exchange for performing service S.
- Bob bids 20 ALICE points to receive service S.
- The matching engine matches Bob's bid with Alice's ask, invoking Alice's
  promise to perform service S for Bob in exchange for 20 ALICE points.
- Alice performs service S, sends the result to the kernel, the kernel
  updates Alice's and Bob's ledgers accordingly, and sends the result
  to Bob.   (Is the matching engine part of the kernel, or a separate
  service?)

# Communication Across Machines

Okay, that all works locally, but what about when Alice and Bob are
not on the same machine?  

## Option A:

The kernel provides a **network interface** that allows agents to
communicate with each other across machines. 

When Alice wants to send a message to Bob, she sends it to the kernel,
which then forwards it to Bob's kernel instance. The kernels in some
way cooperate to discover and 

## Option B:

The kernel provides a **distributed ledger** that allows agents to
communicate with each other across machines.  This distributed ledger
is a hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

When Alice wants to send a message to Bob, she creates a transaction
that specifies the message and sends it to the kernel. The kernel
then broadcasts the transaction to all other kernels in the network,
which then forward it to Bob's kernel instance. The kernels in some
way cooperate to ensure that the message is delivered to Bob's kernel
instance, and that Bob's kernel instance updates its ledger accordingly.

## Option C:

The kernel provides a **decentralized open market** that allows agents to
communicate with each other across machines. This open market is a
hypergraph that stores all transactions and messages between
agents, ensuring that all communication is logged and tamper-evident.

For example:

- Alice create an ASK order to perform service S for 20 ALICE points.
- Alice sends the ASK order to her local kernel K_Alice_.
- K_Alice_ forwards the ASK order to all known peers.
- K_Bob_ receives the ASK order and checks if it matches any of Bob's
  existing BID orders.
- If a match is found, K_Bob_ does what?  The problem here is that we
  would need some sort of coordination or locking mechanism to ensure
  that the two kernels agree to the match, and that they both update
  their ledgers and release escrow accordingly.  This is a
  basic computer science problem.




